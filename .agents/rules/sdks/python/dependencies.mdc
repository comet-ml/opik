---
description: Dependency management and tech stack guidelines for the Python SDK
globs: sdks/python/src/opik/**/*
alwaysApply: false
---
# Python SDK Dependency Management Guidelines

Comprehensive guidelines for managing dependencies and maintaining a clean, efficient dependency tree in the Opik Python SDK.

## Dependency Management

### Core Principles

- **Prioritize keeping existing dependencies** (stored in setup.py) and avoid adding new ones
- **Keep dependency versions flexible** with appropriate bounds
- **Avoid adding heavy dependencies** without strong justification
- **Use conditional imports** for optional dependencies (usually the case for integrations)
- **Make sure the python versions specified in setup.py** can execute new code

### Existing Core Dependencies

```python
# ✅ Current core dependencies (from setup.py)
install_requires=[
    "boto3-stubs[bedrock-runtime]>=1.34.110",
    "click",                                        # CLI interface
    "httpx",                                        # HTTP client
    "rapidfuzz>=3.0.0,<4.0.0",                    # Fast string matching
    "litellm<1.75.0",                              # LLM provider abstraction
    "openai<2.0.0",                                # OpenAI API client
    "pydantic-settings>=2.0.0,<3.0.0,!=2.9.0",   # Settings management
    "pydantic>=2.0.0,<3.0.0",                     # Data validation
    "pytest",                                       # Testing framework
    "rich",                                         # Rich text and progress
    "sentry_sdk>=2.0.0",                           # Error tracking
    "tenacity",                                     # Retry logic
    "tokenizers<0.21.0 ; python_version<'3.9.0'", # Tokenization (Python 3.8 support)
    "tqdm",                                         # Progress bars
    "uuid6",                                        # UUID utilities
    "jinja2",                                       # Template engine
]
```



### Python Version Support

```python
# ✅ Current Python version support
python_requires=">=3.8"

# Supported versions: 3.8, 3.9, 3.10, 3.11, 3.12
classifiers=[
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
```

## Conditional Imports for Integrations

### Lazy Import Pattern

- **Pattern**: Use lazy imports for optional dependencies that may not be installed
- **Example**: LiteLLM integration uses conditional imports
- **Error Handling**: Handle ImportError gracefully

```python
# ✅ Good: Lazy import pattern (from opik_monitor.py)
from typing import Optional

def lazy_import_OpikLogger() -> Optional["litellm.integrations.opik.opik.OpikLogger"]:
    try:
        from litellm.integrations.opik.opik import OpikLogger
        return OpikLogger
    except ImportError:
        return None

def try_add_opik_monitoring_to_params(params: Dict[str, Any]) -> Dict[str, Any]:
    if lazy_import_OpikLogger() is None:
        return params

    # Continue with integration logic
    import litellm
    # ... rest of implementation
```

### Integration Import Patterns

```python
# ✅ Good: Direct import for integration modules
# Integration files assume the dependency is available when imported
import haystack
from haystack import logging, tracing

import crewai
import anthropic
import openai

# The integration is only imported if the user has the dependency
```

### Version-Dependent Imports

```python
# ✅ Good: Version-dependent imports (from adk/__init__.py)
import google.adk
from opik import semantic_version

if semantic_version.SemanticVersion.parse(google.adk.__version__) < "1.3.0":
    from .legacy_opik_tracer import LegacyOpikTracer as OpikTracer
else:
    from .opik_tracer import OpikTracer
```

## Dependency Guidelines

### When to Add New Dependencies

```python
# ✅ Good reasons to add dependencies:
# - Core functionality requirement (HTTP client, data validation)
# - Significant performance improvement
# - Security enhancement
# - Python standard library alternative for compatibility

# ❌ Avoid adding dependencies for:
# - Single utility functions that can be implemented
# - Heavy libraries for minor features
# - Dependencies with poor maintenance
# - Libraries that duplicate existing functionality
```

### Version Constraints

```python
# ✅ Good: Appropriate version bounds
"pydantic>=2.0.0,<3.0.0"                   # Major version constraint
"rapidfuzz>=3.0.0,<4.0.0"                  # Specific range
"litellm<1.75.0"                           # Upper bound for stability
"sentry_sdk>=2.0.0"                        # Minimum version for features
"tokenizers<0.21.0 ; python_version<'3.9.0'"  # Python version specific

# ❌ Bad: Overly restrictive or loose constraints
"pydantic==2.5.1"                          # Too specific
"requests"                                  # No version constraint
"some-lib>=1.0.0"                          # No upper bound
```

### Dependency Review Checklist

Before adding a new dependency:

- [ ] **Necessity**: Is this dependency absolutely required?
- [ ] **Alternatives**: Can existing dependencies provide this functionality?
- [ ] **Maintenance**: Is the dependency actively maintained?
- [ ] **Size**: What is the installation size impact?
- [ ] **License**: Is the license compatible?
- [ ] **Security**: Are there known security issues?
- [ ] **Python Support**: Does it support our Python version range?

## Integration Dependency Patterns

### Optional Integration Dependencies

```python
# ✅ Good: Integration assumes dependency is available
# File: integrations/anthropic/opik_tracker.py
import anthropic
from anthropic import AsyncAnthropic, Anthropic

def track_anthropic(
    anthropic_client: AnthropicClient,
    project_name: Optional[str] = None,
) -> AnthropicClient:
    """Integration code assumes anthropic is installed."""
    # Implementation here
```

### Error Handling for Missing Dependencies

```python
# ✅ Good: Graceful handling of missing optional dependencies
try:
    from some_optional_library import SomeClass
    OPTIONAL_AVAILABLE = True
except ImportError:
    OPTIONAL_AVAILABLE = False
    SomeClass = None

def use_optional_feature():
    if not OPTIONAL_AVAILABLE:
        raise ImportError("Optional library not installed. Install with: pip install some-library")

    return SomeClass()
```

## Performance Considerations

### Import Performance

```python
# ✅ Good: Lazy imports for heavy dependencies
def get_heavy_processor():
    import heavy_ml_library  # Import only when needed
    return heavy_ml_library.Processor()

# ✅ Good: Module-level imports for core dependencies
import httpx
import pydantic
from typing import Optional
```

### Memory Usage

```python
# ✅ Good: Import only what's needed
from typing import Optional, Dict, List  # Specific imports
from pydantic import BaseModel           # Specific classes

# ❌ Bad: Import entire modules unnecessarily
import typing     # Use specific imports instead
import pydantic   # Use specific imports instead
```

## Best Practices

### Dependency Documentation

- **Document integration requirements** in docstrings
- **Provide installation instructions** for optional dependencies
- **List supported versions** for external libraries

### Testing with Dependencies

- **Test with minimum supported versions** of dependencies
- **Test dependency isolation** for integrations
- **Use dependency injection** for testability

### Upgrade Strategy

- **Monitor security advisories** for all dependencies
- **Test upgrades** in isolated environments
- **Update incrementally** rather than bulk updates
- **Maintain backward compatibility** when possible

## Key References

- [API Design Guidelines](api-design.mdc)
- [Architecture Guidelines](architecture.mdc)
- [Error Handling Guidelines](error-handling.mdc)
- [Testing Guidelines](test-organization.mdc)
