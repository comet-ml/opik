---
description: Core library architecture and design patterns for the Python SDK
globs: sdks/python/src/opik/**/*
alwaysApply: false
---
# Python SDK Architecture

## Three-Layer Architecture
```
Layer 1: Public API (opik.Opik, @opik.track, opik_context)
    ↓
Layer 2: Message Processing (observability) | API Object Clients (resources)
    ↓
Layer 3: REST API Client (OpikApi - auto-generated from OpenAPI)
    ↓
Opik Backend (external service)
```

## Two Execution Paths

### Async (via Message Processing) - fire-and-forget
- `trace()`, `span()`, `log_*_feedback_scores()`, `experiment.insert()`, attachments
- Non-blocking, batched, auto-retry, requires `flush()` before exit

### Sync (via API Clients / Direct REST) - blocking
- Dataset/Experiment/Prompt CRUD, `search_*()`, `get_*_content()`, `delete_*()`
- Returns data immediately, no batching, no flush needed

## API Object Clients
- `Dataset`, `Experiment`, `Prompt`, `AttachmentClient`, `ThreadsClient`
- Manage state, handle complex logic, wrap REST calls

## Message Processing Flow
```python
# API calls → Messages → Streamer (routes to queue/batch/upload) → Consumers → MessageProcessor → REST
```

### Batching Triggers
1. Time-based (periodic)
2. Size-based (100 messages)
3. Memory-based (50MB)
4. Manual (`flush()`)
5. Shutdown

## Context Storage
- Uses `contextvars` for thread-safe trace/span lifecycle
- `context_storage.set_trace_data()`, `opik_context.update_current_trace()`

## Integration Patterns
| Library Architecture | Pattern |
|---------------------|---------|
| Has callbacks/hooks (reliable) | Pure Callback (LangChain, LlamaIndex) |
| Has callbacks (unreliable) | Hybrid Callback + Patching (ADK) |
| No callbacks | Method Patching (OpenAI, Anthropic, Bedrock) |

## Evaluation Engine
| Method | Dataset | Task | Source |
|--------|---------|------|--------|
| `evaluate()` | Required | Required | Executes on dataset |
| `evaluate_prompt()` | Required | Auto-gen | Executes prompt |
| `evaluate_experiment()` | From exp | Not needed | Existing data |
| `evaluate_threads()` | Not needed | Not needed | Backend traces |

## Best Practices
- Separate API, message processing, REST layers
- Use background processing for observability ops
- Synchronous evaluation (unlike tracing)
- Proper context management for concurrent ops
- Always `flush()` before app exit
