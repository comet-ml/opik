---
description: Business Logic Guidelines
globs: apps/opik-backend/**/*
alwaysApply: false
---

# Business Logic Guidelines

Comprehensive guidelines for implementing business logic in the Opik backend using proper patterns and best practices.

## Dependency Injection and Annotations

### **Use Annotations for Dependency Management**

- Use annotations when possible for cleaner, more maintainable code
- Leverage Lombok annotations to reduce boilerplate
- Use Guice annotations for dependency injection

```java
// Good example - Using annotations
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    private final @NonNull ResourceDao resourceDao;
    private final @NonNull IdGenerator idGenerator;
    private final @NonNull TransactionTemplate transactionTemplate;
    
    // Business logic methods
}

// Bad example - Manual constructor injection
public class ResourceService {
    
    private final ResourceDao resourceDao;
    private final IdGenerator idGenerator;
    
    @Inject
    public ResourceService(ResourceDao resourceDao, IdGenerator idGenerator) {
        this.resourceDao = resourceDao;
        this.idGenerator = idGenerator;
    }
}
```

### **Common Annotations**

- `@Singleton` - Single instance per application
- `@RequiredArgsConstructor(onConstructor_ = @Inject)` - Automatic constructor generation
- `@NonNull` - Null safety for required dependencies
- `@Slf4j` - Automatic logger injection

## Database Access with JDBI3

### **Transaction Management**

- Use JDBI3 for MySQL with TransactionTemplate
- Always wrap MySQL database operations in transactions
- Use appropriate transaction types (READ/WRITE)

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    private final @NonNull ResourceDao resourceDao;
    private final @NonNull TransactionTemplate transactionTemplate;

    public ResourceResponse createResource(ResourceCreateRequest request) {
        return transactionTemplate.inTransaction(WRITE, handle -> {
            var repository = handle.attach(ResourceDao.class);
            
            var resource = Resource.builder()
                .id(idGenerator.generate())
                .name(request.getName())
                .type(request.getType())
                .createdAt(Instant.now())
                .build();
            
            return repository.create(resource);
        });
    }

    public ResourceResponse getResource(String id) {
        return transactionTemplate.inTransaction(READ_ONLY, handle -> {
            var repository = handle.attach(ResourceDao.class);
            return repository.findById(id)
                .orElseThrow(() -> new NotFoundException("Resource not found: '%s'".formatted(id)));
        });
    }
}
```

### **Transaction Types**

```java
import static com.comet.opik.infrastructure.db.TransactionTemplateAsync.READ_ONLY;
import static com.comet.opik.infrastructure.db.TransactionTemplateAsync.WRITE;

// For read operations
transactionTemplate.inTransaction(READ_ONLY, handle -> {
    // Read-only database operations
});

// For write operations
transactionTemplate.inTransaction(WRITE, handle -> {
    // Write database operations
});
```

## ID Generation

### **UUID Generation with IdGenerator**

- Inject and use IdGenerator for UUIDs v7
- Use consistent ID generation across the application
- Ensure IDs are unique and properly formatted and proper version (UUID v7)

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    private final @NonNull IdGenerator idGenerator;
    
    public ResourceResponse createResource(ResourceCreateRequest request) {
        var resource = Resource.builder()
            .id(idGenerator.generate())  // Generate UUID
            .name(request.getName())
            .type(request.getType())
            .createdAt(Instant.now())
            .build();
        
        return resourceDao.create(resource);
    }
}
```

### **ID Generator Usage**

```java
// Import the IdGenerator
import com.comet.opik.domain.IdGenerator;

// Inject as a dependency
private final @NonNull IdGenerator idGenerator;

// Use in business logic
String id = idGenerator.generate();
```

## Business Logic Patterns

### **Service Layer Implementation**

- Keep business logic in service classes
- Use dependency injection for dependencies
- Implement proper error handling
- Use builder patterns for object creation

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    private final @NonNull ResourceDao resourceDao;
    private final @NonNull IdGenerator idGenerator;
    private final @NonNull ValidationService validationService;

    public ResourceResponse createResource(ResourceCreateRequest request) {
        // Validate input
        validationService.validateResourceRequest(request);
        
        // Generate ID
        String id = idGenerator.generate();
        
        // Build entity
        var resource = Resource.builder()
            .id(id)
            .name(request.getName())
            .type(request.getType())
            .createdAt(Instant.now())
            .build();
        
        // Persist to database
        return resourceDao.create(resource);
    }

    public ResourceResponse updateResource(String id, ResourceUpdateRequest request) {
        // Find existing resource
        var existingResource = resourceDao.findById(id)
            .orElseThrow(() -> new NotFoundException("Resource not found: '%s'".formatted(id)));
        
        // Update fields
        var updatedResource = existingResource.toBuilder()
            .name(request.getName())
            .type(request.getType())
            .updatedAt(Instant.now())
            .build();
        
        // Persist changes
        return resourceDao.update(updatedResource);
    }
}
```

### **Validation in Business Logic**

- Validate inputs before processing
- Use custom validation services
- Provide meaningful error messages

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ValidationService {
    
    public void validateResourceRequest(ResourceCreateRequest request) {
        if (request.getName() == null || request.getName().trim().isEmpty()) {
            throw new ValidationException("Resource name is required");
        }
        
        if (request.getType() == null) {
            throw new ValidationException("Resource type is required");
        }
        
        // Additional business validation rules
        if (request.getName().length() > 255) {
            throw new ValidationException("Resource name cannot exceed 255 characters");
        }
    }
}
```

## Error Handling

### **Business Exception Handling**

- Use specific exception types for business errors
- Provide meaningful error messages
- Log errors with appropriate context

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    private final @NonNull ResourceDao resourceDao;
    private final @NonNull IdGenerator idGenerator;
    
    public ResourceResponse getResource(String id) {
        try {
            return resourceDao.findById(id)
                .orElseThrow(() -> new NotFoundException("Resource not found: '%s'".formatted(id)));
        } catch (Exception e) {
            log.error("Failed to retrieve resource with id: {}", id, e);
            throw new BusinessException("Failed to retrieve resource", e);
        }
    }
}
```

### **Exception Types**

- Attempt reusing existing exception types.
- Favour either standard Java exceptions or Jakarta, choosing the appropiate one for the situation.
- Only create new exception types when there's no other option.

## Logging and Observability

### **Structured Logging**

- Use SLF4J for logging
- Include relevant context in log messages
- Log at appropriate levels
- Avoid logging PII (name, email etc.), sensitive or insecure data (passwords, keys etc.)

```java
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    public ResourceResponse createResource(ResourceCreateRequest request) {
        log.info("Creating resource with name: {}", request.getName());
        
        try {
            var resource = // ... implementation
            log.info("Successfully created resource with id: {}", resource.getId());
            return resource;
        } catch (Exception exception) {
            log.error("Failed to create resource: {}", request.getName(), e);
            throw exception;
        }
    }
}
```

## Best Practices

### **Code Organization**

- Keep business logic focused and single-purpose
- Use meaningful method names
- Extract complex logic into separate methods
- Use constants for magic numbers

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourceService {
    
    private static final int MAX_NAME_LENGTH = 255;
    private static final Duration CACHE_DURATION = Duration.ofMinutes(30);
    
    public ResourceResponse createResource(ResourceCreateRequest request) {
        validateRequest(request);
        var resource = buildResource(request);
        return persistResource(resource);
    }
    
    private void validateRequest(ResourceCreateRequest request) {
        // Validation logic
    }
    
    private Resource buildResource(ResourceCreateRequest request) {
        // Resource building logic
    }
    
    private ResourceResponse persistResource(Resource resource) {
        // Persistence logic
    }
}
```

### **Dependency Management**

- Use constructor injection
- Mark required dependencies as `@NonNull`
- Avoid circular dependencies
- Keep dependencies minimal

### **Testing Business Logic**

- Test business logic thoroughly
- Use mocks for external dependencies
- Test both success and failure scenarios

```java
@Test
void shouldCreateResource_whenValidRequest() {
    // Given
    var request = new ResourceCreateRequest("Test Resource", ResourceType.BASIC);
    var expectedId = "test-uuid";
    
    when(idGenerator.generate()).thenReturn(expectedId);
    when(resourceDao.create(any(Resource.class))).thenReturn(expectedResource);
    
    // When
    var result = resourceService.createResource(request);
    
    // Then
    assertThat(result.getId()).isEqualTo(expectedId);
    assertThat(result.getName()).isEqualTo("Test Resource");
    verify(resourceDao).create(any(Resource.class));
}
```

## Key References

- [JDBI3 Database Access](https://jdbi.org/)
- [Lombok Annotations](https://projectlombok.org/features/all)
- [SLF4J Logging](http://www.slf4j.org/)
- [Dropwizard Best Practices](https://www.dropwizard.io/en/latest/manual/core.html)
