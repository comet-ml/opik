---
description: Import organization, module layout, and access control for Opik Optimizer SDK
globs: sdks/opik_optimizer/src/opik_optimizer/**/*
alwaysApply: false
---
# Opik Optimizer Code Structure

Keep modules small, explicit, and aligned with the optimizer architecture so contributors can navigate the SDK quickly.

## Imports

- Order imports as: standard library -> third-party -> Opik/Opik Optimizer modules.
- Use absolute imports when referencing other packages inside `opik_optimizer` (`from opik_optimizer.api_objects import chat_prompt`). Reserve relative imports for local siblings within the same package.
- Guard optional dependencies (for example, `gepa`, `langgraph`, `torch`) inside functions or `try/except ImportError` blocks so the base install works without extras.

## Standardized Algorithm Structure

**All optimizer algorithms MUST follow this standardized structure:**

```
{algorithm_name}/
├── __init__.py              # Required: exports optimizer class
├── {algorithm_name}.py      # Required: main optimizer implementation
├── helpers.py               # Required: utility functions (can be minimal)
├── types.py                 # Required: type definitions (can be minimal)
├── prompts.py               # Required: prompt templates (can be minimal)
├── reporting.py             # Required: reporting utilities (can be minimal)
├── adapter.py               # Optional: only if algorithm needs adapter
└── ops/                     # Optional: only if algorithm has discrete operations
    ├── __init__.py
    └── {operation}.py
```

### Required Files

- **`__init__.py`**: Must export the optimizer class in `__all__`
- **`{algorithm_name}.py`**: Main optimizer class inheriting from `BaseOptimizer`
  - Implements `run_optimization()` (required)
  - Optionally implements `pre_optimization()`, `get_config()`, `get_metadata()`
- **`helpers.py`**: Utility functions used by the optimizer
  - Can be minimal/empty if no utilities needed
  - Add docstring explaining purpose if empty
- **`types.py`**: Type definitions, enums, and data classes
  - Can be minimal/empty if no custom types needed
  - Add docstring explaining purpose if empty
- **`prompts.py`**: LLM prompt templates for algorithm operations
  - Can be minimal/empty if algorithm doesn't use LLM prompts
  - Export `DEFAULT_PROMPTS` dictionary for `BaseOptimizer.DEFAULT_PROMPTS`
- **`reporting.py`**: Reporting utilities and context managers
  - Can import from `...reporting_utils` for standard reporting
  - Can be minimal if using standard reporting only

### Optional Files

- **`adapter.py`**: Only if algorithm needs an adapter (e.g., `gepa_optimizer`)
- **`ops/`**: Only if algorithm has discrete operations that benefit from separation
  - Examples: `generation_ops.py`, `evaluation_ops.py`, `selection_ops.py`
  - Use when operations are complex enough to warrant separate modules

### Algorithm-Specific Files

- Algorithm-specific domain models or utilities can be added as needed
  - Examples: `parameter_search_space.py`, `parameter_spec.py` (parameter_optimizer)
  - Keep these when they represent core domain concepts

### Template Reference

See `src/opik_optimizer/algorithms/template_optimizer/` for a complete working template demonstrating:
- All required BaseOptimizer hooks
- Standardized file structure
- Example implementations with placeholders
- Pass-through implementation for testing structure

## Directory Layout

```
src/opik_optimizer/
├── base_optimizer.py
├── core/
│   ├── __init__.py
│   ├── evaluation.py
│   ├── llm_calls.py
│   ├── results.py
│   └── state.py
├── optimization_result.py
├── task_evaluator.py
├── _llm_calls.py
├── agents/
│   └── optimizable_agent.py
├── optimization_config/
├── datasets/
├── utils/
├── metrics/
├── integrations/
├── algorithms/
│   └── {optimizer}/
│       ├── __init__.py
│       ├── {optimizer}.py
│       ├── helpers.py
│       ├── types.py
│       ├── prompts.py
│       ├── reporting.py
│       ├── adapter.py (optional)
│       └── ops/ (optional)
│           ├── __init__.py
│           └── {operation}.py
└── mcp_utils/
```

- Replace `{optimizer}` with concrete packages such as `evolutionary_optimizer`, `meta_prompt_optimizer`, `parameter_optimizer`, etc.
- All optimizers must follow the standardized structure above
- Split new logic into focused modules when a file grows beyond ~300 lines or mixes concerns
- Keep algorithm-specific helpers inside the corresponding optimizer package
- Shared utilities that are reused across optimizers live in top-level directories (`utils/`, `optimization_config/`, `metrics/`, `mcp_utils/`)
- `optimization_result.py`, `task_evaluator.py`, and `_llm_calls.py` are compatibility shims that re-export from `core/` for legacy imports; new code should prefer `core/` modules.

## Public Surface

- Re-export public optimizers from package `__init__.py` files so users can import with `from opik_optimizer import EvolutionaryOptimizer`.
- Keep internal helpers private with a leading underscore or by omitting them from `__all__`.

## Module State and Configuration

- Avoid work at import time beyond constant definition and lightweight configuration (`initialize_cache()` is triggered inside `BaseOptimizer`, not at module load).
- Store configurable defaults as uppercase constants near the top of the module (for example, `DEFAULT_POPULATION_SIZE`).
- When you need mutable shared state (caches, counters), encapsulate it in a dedicated module (`cache_config`, `utils/throttle.py`) rather than scattering globals.

## Typing and Data Structures

- Type annotate public methods and helper functions. Use `pydantic.BaseModel`, dataclasses, or TypedDicts for structured data exchanged between modules (for example, `OptimizationResult`, prompt variants).
- Prefer immutable structures (tuples, frozen dataclasses) for candidate representations passed between operators to avoid accidental mutation.
