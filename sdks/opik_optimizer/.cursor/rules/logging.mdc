---
description: Logging patterns and verbosity guidelines for Opik Optimizer SDK
globs: sdks/opik_optimizer/src/opik_optimizer/**/*
alwaysApply: false
---
# Opik Optimizer Logging

Use consistent logging so optimisation runs can be monitored locally and inside Opik traces.

## Logger Setup

- Declare a module-level logger with `logger = logging.getLogger(__name__)`.
- Call `logging_config.setup_logging()` (or expect callers to do so) before emitting logs; it wires the Rich handler and propagates `OPIK_LOG_LEVEL` overrides.
- Access progress bars via `opik.environment.get_tqdm_for_current_environment()` instead of printing raw status lines.

## Log Levels

- `INFO`: High-level lifecycle events (start/end of optimisation, generation summaries, baseline scores).
- `DEBUG`: Candidate details, mutation operator choices, retry diagnostics. Wrap expensive formatting in `if logger.isEnabledFor(logging.DEBUG)`.
- `WARNING`: Recoverable issues (failed candidate evaluation, throttled requests, Opik API hiccups).
- `ERROR`: Failures that abort the optimisation run.

## Structured Messages

- Include context such as `optimization_id`, `iteration`, `best_score`, or `population_size` in log messages. Prefer keyword arguments or formatted dicts over concatenated strings for readability.
- When logging prompts or outputs, truncate to a reasonable length and avoid leaking secrets.

## Reporting vs Logging

- Reserve logging for machine-readable diagnostics. Use `reporting_utils` context managers for user-facing console output; they already respect the `verbose` flag.
- Avoid mixing `print` statements with logging. If temporary prints are necessary during debugging, remove them before committing.
