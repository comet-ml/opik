---
description: Dependency management and versioning for Opik Optimizer SDK
globs: sdks/opik_optimizer/**/*
alwaysApply: false
---
# Opik Optimizer Dependencies

Manage dependencies deliberately so the optimizer package remains lightweight while still supporting advanced optimisers and integrations.

## Runtime Dependencies

- Declared in `sdks/opik_optimizer/setup.py`. Core packages include `litellm`, `opik`, `optuna`, `deap`, `diskcache`, `pydantic`, `pandas`, `pyrate-limiter`, `hf_xet`, `ujson`, `tqdm`, and `rich`.
- Honour `python_requires=">=3.10,<3.14"` - new language features must keep Python 3.10 compatibility.
- Keep heavyweight or niche integrations (for example, `gepa`, `langgraph`) in extras (`extras_require["dev"]`) or feature-specific requirements. Guard imports so base users are prompted with a clear installation hint.

## Test and Dev Requirements

- Test-only dependencies live in `tests/test_requirements.txt` (e.g. `pytest`, `pytest-asyncio`, `pytest-cov`, `orderly_set==5.3.2`, `gepa>=0.0.7`). Update this file when tests rely on new packages and document pins inline.
- Notebooks and benchmarks may have their own requirements; prefer per-tool requirements files over bloating runtime dependencies.

## Adding or Updating Dependencies

1. Confirm the standard library or existing dependencies cannot cover the use case.
2. Add the package to `setup.py` (and `tests/test_requirements.txt` when applicable) with a justified version range. Reference upstream issues in comments when applying tight pins.
3. Guard imports in code using `try/except ImportError` with actionable error messages (`"Install opik-optimizer[dev]"`).
4. Run unit and e2e tests to verify the new dependency behaves as expected across optimizers.
5. Update documentation (README, notebooks) mentioning new installation steps or extras.

## Security and Licensing

- Prefer actively maintained libraries compatible with Apache 2.0.
- Do not commit API keys, private indexes, or credentials alongside dependency updates.
- Monitor `litellm`, `optuna`, and provider SDK releases: breaking changes often require upper bounds or compatibility shims.
