// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as serializers from "../../../../serialization/index.js";
import * as OpikApi from "../../../index.js";

export declare namespace DatasetsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

/**
 * Dataset resources
 */
export class DatasetsClient {
    protected readonly _options: NormalizedClientOptions<DatasetsClient.Options>;

    constructor(options: DatasetsClient.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    /**
     * Apply delta changes (add, edit, delete) to a dataset version with conflict detection.
     *
     * This endpoint:
     * - Creates a new version with the applied changes
     * - Validates that baseVersion matches the latest version (unless override=true)
     * - Returns 409 Conflict if baseVersion is stale and override is not set
     *
     * Use `override=true` query parameter to force version creation even with stale baseVersion.
     *
     * @param {string} id
     * @param {OpikApi.ApplyDatasetItemChangesRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.datasets.applyDatasetItemChanges("id", {
     *         body: {
     *             "key": "value"
     *         }
     *     })
     */
    public applyDatasetItemChanges(
        id: string,
        request: OpikApi.ApplyDatasetItemChangesRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetVersionPublic> {
        return core.HttpResponsePromise.fromPromise(this.__applyDatasetItemChanges(id, request, requestOptions));
    }

    private async __applyDatasetItemChanges(
        id: string,
        request: OpikApi.ApplyDatasetItemChangesRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetVersionPublic>> {
        const { override, body: _body } = request;
        const _queryParams: Record<string, unknown> = {
            override,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/items/changes`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.DatasetItemChangesPublic.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetVersionPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                case 409:
                    throw new OpikApi.ConflictError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{id}/items/changes",
        );
    }

    /**
     * Update multiple dataset items
     *
     * @param {OpikApi.DatasetItemBatchUpdate} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.datasets.batchUpdateDatasetItems({
     *         update: {}
     *     })
     */
    public batchUpdateDatasetItems(
        request: OpikApi.DatasetItemBatchUpdate,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__batchUpdateDatasetItems(request, requestOptions));
    }

    private async __batchUpdateDatasetItems(
        request: OpikApi.DatasetItemBatchUpdate,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/items/batch",
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetItemBatchUpdate.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v1/private/datasets/items/batch",
        );
    }

    /**
     * Find datasets
     *
     * @param {OpikApi.FindDatasetsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.findDatasets()
     */
    public findDatasets(
        request: OpikApi.FindDatasetsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetPagePublic> {
        return core.HttpResponsePromise.fromPromise(this.__findDatasets(request, requestOptions));
    }

    private async __findDatasets(
        request: OpikApi.FindDatasetsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetPagePublic>> {
        const { page, size, withExperimentsOnly, withOptimizationsOnly, promptId, name, sorting, filters } = request;
        const _queryParams: Record<string, unknown> = {
            page,
            size,
            with_experiments_only: withExperimentsOnly,
            with_optimizations_only: withOptimizationsOnly,
            prompt_id: promptId,
            name,
            sorting,
            filters,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetPagePublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v1/private/datasets");
    }

    /**
     * Create dataset
     *
     * @param {OpikApi.DatasetWrite} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDataset({
     *         name: "name"
     *     })
     */
    public createDataset(
        request: OpikApi.DatasetWrite,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__createDataset(request, requestOptions));
    }

    private async __createDataset(
        request: OpikApi.DatasetWrite,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetWrite.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/private/datasets");
    }

    /**
     * Create/update dataset items based on dataset item id
     *
     * @param {OpikApi.DatasetItemBatchWrite} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createOrUpdateDatasetItems({
     *         items: [{
     *                 source: "manual",
     *                 data: {
     *                     "key": "value"
     *                 }
     *             }]
     *     })
     */
    public createOrUpdateDatasetItems(
        request: OpikApi.DatasetItemBatchWrite,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__createOrUpdateDatasetItems(request, requestOptions));
    }

    private async __createOrUpdateDatasetItems(
        request: OpikApi.DatasetItemBatchWrite,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/items",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetItemBatchWrite.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/v1/private/datasets/items");
    }

    /**
     * Create dataset items from uploaded CSV file. CSV should have headers in the first row. Processing happens asynchronously in batches.
     *
     * @param {OpikApi.CreateDatasetItemsFromCsvRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.datasets.createDatasetItemsFromCsv({
     *         file: {
     *             "key": "value"
     *         },
     *         datasetId: "dataset_id"
     *     })
     */
    public createDatasetItemsFromCsv(
        request: OpikApi.CreateDatasetItemsFromCsvRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__createDatasetItemsFromCsv(request, requestOptions));
    }

    private async __createDatasetItemsFromCsv(
        request: OpikApi.CreateDatasetItemsFromCsvRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _body = await core.newFormData();
        _body.append("file", toJson(request.file));
        _body.append("dataset_id", request.datasetId);
        const _maybeEncodedRequest = await _body.getRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/items/from-csv",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/items/from-csv",
        );
    }

    /**
     * Create dataset items from spans with enriched metadata
     *
     * @param {string} dataset_id
     * @param {OpikApi.CreateDatasetItemsFromSpansRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDatasetItemsFromSpans("dataset_id", {
     *         spanIds: ["span_ids"],
     *         enrichmentOptions: {}
     *     })
     */
    public createDatasetItemsFromSpans(
        dataset_id: string,
        request: OpikApi.CreateDatasetItemsFromSpansRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(
            this.__createDatasetItemsFromSpans(dataset_id, request, requestOptions),
        );
    }

    private async __createDatasetItemsFromSpans(
        dataset_id: string,
        request: OpikApi.CreateDatasetItemsFromSpansRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(dataset_id)}/items/from-spans`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.CreateDatasetItemsFromSpansRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{dataset_id}/items/from-spans",
        );
    }

    /**
     * Create dataset items from traces with enriched metadata
     *
     * @param {string} dataset_id
     * @param {OpikApi.CreateDatasetItemsFromTracesRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDatasetItemsFromTraces("dataset_id", {
     *         traceIds: ["trace_ids"],
     *         enrichmentOptions: {}
     *     })
     */
    public createDatasetItemsFromTraces(
        dataset_id: string,
        request: OpikApi.CreateDatasetItemsFromTracesRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(
            this.__createDatasetItemsFromTraces(dataset_id, request, requestOptions),
        );
    }

    private async __createDatasetItemsFromTraces(
        dataset_id: string,
        request: OpikApi.CreateDatasetItemsFromTracesRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(dataset_id)}/items/from-traces`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.CreateDatasetItemsFromTracesRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{dataset_id}/items/from-traces",
        );
    }

    /**
     * Get dataset by id
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetByIdRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetById("id")
     */
    public getDatasetById(
        id: string,
        request: OpikApi.GetDatasetByIdRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetPublic> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetById(id, request, requestOptions));
    }

    private async __getDatasetById(
        id: string,
        _request: OpikApi.GetDatasetByIdRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v1/private/datasets/{id}");
    }

    /**
     * Update dataset by id
     *
     * @param {string} id
     * @param {OpikApi.DatasetUpdate} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.updateDataset("id", {
     *         name: "name"
     *     })
     */
    public updateDataset(
        id: string,
        request: OpikApi.DatasetUpdate,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__updateDataset(id, request, requestOptions));
    }

    private async __updateDataset(
        id: string,
        request: OpikApi.DatasetUpdate,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetUpdate.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/v1/private/datasets/{id}");
    }

    /**
     * Delete dataset by id
     *
     * @param {string} id
     * @param {OpikApi.DeleteDatasetRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDataset("id")
     */
    public deleteDataset(
        id: string,
        request: OpikApi.DeleteDatasetRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteDataset(id, request, requestOptions));
    }

    private async __deleteDataset(
        id: string,
        _request: OpikApi.DeleteDatasetRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v1/private/datasets/{id}");
    }

    /**
     * Delete dataset by name
     *
     * @param {OpikApi.DatasetIdentifier} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetByName({
     *         datasetName: "dataset_name"
     *     })
     */
    public deleteDatasetByName(
        request: OpikApi.DatasetIdentifier,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteDatasetByName(request, requestOptions));
    }

    private async __deleteDatasetByName(
        request: OpikApi.DatasetIdentifier,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/delete",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetIdentifier.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v1/private/datasets/delete");
    }

    /**
     * Delete dataset items using one of two modes:
     * 1. **Delete by IDs**: Provide 'item_ids' to delete specific items by their IDs
     * 2. **Delete by filters**: Provide 'dataset_id' with optional 'filters' to delete items matching criteria
     *
     * When using filters, an empty 'filters' array will delete all items in the specified dataset.
     *
     * @param {OpikApi.DatasetItemsDelete} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.datasets.deleteDatasetItems()
     */
    public deleteDatasetItems(
        request: OpikApi.DatasetItemsDelete = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteDatasetItems(request, requestOptions));
    }

    private async __deleteDatasetItems(
        request: OpikApi.DatasetItemsDelete = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/items/delete",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetItemsDelete.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/items/delete",
        );
    }

    /**
     * Delete datasets batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetsBatch({
     *         ids: ["ids"]
     *     })
     */
    public deleteDatasetsBatch(
        request: OpikApi.BatchDelete,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteDatasetsBatch(request, requestOptions));
    }

    private async __deleteDatasetsBatch(
        request: OpikApi.BatchDelete,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/delete-batch",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.BatchDelete.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/delete-batch",
        );
    }

    /**
     * Downloads the exported CSV file for a completed export job. This endpoint proxies the file download to avoid exposing internal storage URLs.
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     */
    public downloadDatasetExport(
        jobId: string,
        request: OpikApi.DownloadDatasetExportRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<ReadableStream<Uint8Array>> {
        return core.HttpResponsePromise.fromPromise(this.__downloadDatasetExport(jobId, request, requestOptions));
    }

    private async __downloadDatasetExport(
        jobId: string,
        _request: OpikApi.DownloadDatasetExportRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<ReadableStream<Uint8Array>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher<ReadableStream<Uint8Array>>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/export-jobs/${core.url.encodePathParam(jobId)}/download`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "streaming",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/export-jobs/{jobId}/download",
        );
    }

    /**
     * Generate synthetic dataset samples using LLM based on existing data patterns
     *
     * @param {string} id
     * @param {OpikApi.DatasetExpansionWrite} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.expandDataset("id", {
     *         model: "gpt-4"
     *     })
     */
    public expandDataset(
        id: string,
        request: OpikApi.DatasetExpansionWrite,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetExpansionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__expandDataset(id, request, requestOptions));
    }

    private async __expandDataset(
        id: string,
        request: OpikApi.DatasetExpansionWrite,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetExpansionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/expansions`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetExpansionWrite.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetExpansionResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{id}/expansions",
        );
    }

    /**
     * Find dataset items with experiment items
     *
     * @param {string} id
     * @param {OpikApi.FindDatasetItemsWithExperimentItemsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.findDatasetItemsWithExperimentItems("id", {
     *         experimentIds: "experiment_ids"
     *     })
     */
    public findDatasetItemsWithExperimentItems(
        id: string,
        request: OpikApi.FindDatasetItemsWithExperimentItemsRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetItemPageCompare> {
        return core.HttpResponsePromise.fromPromise(
            this.__findDatasetItemsWithExperimentItems(id, request, requestOptions),
        );
    }

    private async __findDatasetItemsWithExperimentItems(
        id: string,
        request: OpikApi.FindDatasetItemsWithExperimentItemsRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetItemPageCompare>> {
        const { page, size, experimentIds, filters, sorting, search, truncate } = request;
        const _queryParams: Record<string, unknown> = {
            page,
            size,
            experiment_ids: experimentIds,
            filters,
            sorting,
            search,
            truncate,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/items/experiments/items`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetItemPageCompare.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/{id}/items/experiments/items",
        );
    }

    /**
     * Get dataset by name
     *
     * @param {OpikApi.DatasetIdentifierPublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetByIdentifier({
     *         datasetName: "dataset_name"
     *     })
     */
    public getDatasetByIdentifier(
        request: OpikApi.DatasetIdentifierPublic,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetPublic> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetByIdentifier(request, requestOptions));
    }

    private async __getDatasetByIdentifier(
        request: OpikApi.DatasetIdentifierPublic,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/retrieve",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetIdentifierPublic.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/retrieve",
        );
    }

    /**
     * Get experiment items stats for dataset
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetExperimentItemsStatsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetExperimentItemsStats("id", {
     *         experimentIds: "experiment_ids"
     *     })
     */
    public getDatasetExperimentItemsStats(
        id: string,
        request: OpikApi.GetDatasetExperimentItemsStatsRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.ProjectStatsPublic> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetExperimentItemsStats(id, request, requestOptions));
    }

    private async __getDatasetExperimentItemsStats(
        id: string,
        request: OpikApi.GetDatasetExperimentItemsStatsRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.ProjectStatsPublic>> {
        const { experimentIds, filters } = request;
        const _queryParams: Record<string, unknown> = {
            experiment_ids: experimentIds,
            filters,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/items/experiments/items/stats`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.ProjectStatsPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/{id}/items/experiments/items/stats",
        );
    }

    /**
     * Retrieves the current status of a dataset export job
     *
     * @param {string} jobId
     * @param {OpikApi.GetDatasetExportJobRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.getDatasetExportJob("jobId")
     */
    public getDatasetExportJob(
        jobId: string,
        request: OpikApi.GetDatasetExportJobRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetExportJobPublic> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetExportJob(jobId, request, requestOptions));
    }

    private async __getDatasetExportJob(
        jobId: string,
        _request: OpikApi.GetDatasetExportJobRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetExportJobPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/export-jobs/${core.url.encodePathParam(jobId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetExportJobPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/export-jobs/{jobId}",
        );
    }

    /**
     * Retrieves all export jobs for the workspace. This is used to restore the export panel state after page refresh.
     *
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetExportJobs()
     */
    public getDatasetExportJobs(
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetExportJobPublic[]> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetExportJobs(requestOptions));
    }

    private async __getDatasetExportJobs(
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetExportJobPublic[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/export-jobs",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.datasets.getDatasetExportJobs.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/export-jobs",
        );
    }

    /**
     * Get dataset item by id
     *
     * @param {string} itemId
     * @param {OpikApi.GetDatasetItemByIdRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItemById("itemId")
     */
    public getDatasetItemById(
        itemId: string,
        request: OpikApi.GetDatasetItemByIdRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetItemPublic> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetItemById(itemId, request, requestOptions));
    }

    private async __getDatasetItemById(
        itemId: string,
        _request: OpikApi.GetDatasetItemByIdRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetItemPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/items/${core.url.encodePathParam(itemId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetItemPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/items/{itemId}",
        );
    }

    /**
     * Partially update dataset item by id. Only provided fields will be updated.
     *
     * @param {string} itemId
     * @param {OpikApi.PatchDatasetItemRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.patchDatasetItem("itemId", {
     *         body: {
     *             source: "manual",
     *             data: {
     *                 "key": "value"
     *             }
     *         }
     *     })
     */
    public patchDatasetItem(
        itemId: string,
        request: OpikApi.PatchDatasetItemRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__patchDatasetItem(itemId, request, requestOptions));
    }

    private async __patchDatasetItem(
        itemId: string,
        request: OpikApi.PatchDatasetItemRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { body: _body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/items/${core.url.encodePathParam(itemId)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetItemWrite.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v1/private/datasets/items/{itemId}",
        );
    }

    /**
     * Get dataset items
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetItemsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItems("id")
     */
    public getDatasetItems(
        id: string,
        request: OpikApi.GetDatasetItemsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetItemPagePublic> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetItems(id, request, requestOptions));
    }

    private async __getDatasetItems(
        id: string,
        request: OpikApi.GetDatasetItemsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetItemPagePublic>> {
        const { page, size, version, filters, truncate } = request;
        const _queryParams: Record<string, unknown> = {
            page,
            size,
            version,
            filters,
            truncate,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/items`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetItemPagePublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/{id}/items",
        );
    }

    /**
     * Get dataset items output columns
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetItemsOutputColumnsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItemsOutputColumns("id")
     */
    public getDatasetItemsOutputColumns(
        id: string,
        request: OpikApi.GetDatasetItemsOutputColumnsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.PageColumns> {
        return core.HttpResponsePromise.fromPromise(this.__getDatasetItemsOutputColumns(id, request, requestOptions));
    }

    private async __getDatasetItemsOutputColumns(
        id: string,
        request: OpikApi.GetDatasetItemsOutputColumnsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.PageColumns>> {
        const { experimentIds } = request;
        const _queryParams: Record<string, unknown> = {
            experiment_ids: experimentIds,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/items/experiments/items/output/columns`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.PageColumns.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/{id}/items/experiments/items/output/columns",
        );
    }

    /**
     * Marks a dataset export job as viewed by setting the viewed_at timestamp. This is used to track that a user has seen a failed job's error message. This operation is idempotent.
     *
     * @param {string} jobId
     * @param {OpikApi.MarkDatasetExportJobViewedRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.markDatasetExportJobViewed("jobId")
     */
    public markDatasetExportJobViewed(
        jobId: string,
        request: OpikApi.MarkDatasetExportJobViewedRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__markDatasetExportJobViewed(jobId, request, requestOptions));
    }

    private async __markDatasetExportJobViewed(
        jobId: string,
        _request: OpikApi.MarkDatasetExportJobViewedRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/export-jobs/${core.url.encodePathParam(jobId)}/mark-viewed`,
            ),
            method: "PUT",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PUT",
            "/v1/private/datasets/export-jobs/{jobId}/mark-viewed",
        );
    }

    /**
     * Initiates an asynchronous CSV export job for the dataset. Returns immediately with job details for polling.
     *
     * @param {string} id
     * @param {OpikApi.StartDatasetExportRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.startDatasetExport("id")
     */
    public startDatasetExport(
        id: string,
        request: OpikApi.StartDatasetExportRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetExportJobPublic> {
        return core.HttpResponsePromise.fromPromise(this.__startDatasetExport(id, request, requestOptions));
    }

    private async __startDatasetExport(
        id: string,
        _request: OpikApi.StartDatasetExportRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetExportJobPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/export`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetExportJobPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{id}/export",
        );
    }

    /**
     * Stream dataset items
     */
    public streamDatasetItems(
        request: OpikApi.DatasetItemStreamRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<ReadableStream<Uint8Array>> {
        return core.HttpResponsePromise.fromPromise(this.__streamDatasetItems(request, requestOptions));
    }

    private async __streamDatasetItems(
        request: OpikApi.DatasetItemStreamRequest,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<ReadableStream<Uint8Array>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher<ReadableStream<Uint8Array>>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                "v1/private/datasets/items/stream",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetItemStreamRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            responseType: "streaming",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/items/stream",
        );
    }

    /**
     * Compare the latest committed dataset version with the current draft state. This endpoint provides insights into changes made since the last version was committed. The comparison calculates additions, modifications, deletions, and unchanged items between the latest version snapshot and current draft.
     *
     * @param {string} id
     * @param {OpikApi.CompareDatasetVersionsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.compareDatasetVersions("id")
     */
    public compareDatasetVersions(
        id: string,
        request: OpikApi.CompareDatasetVersionsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetVersionDiff> {
        return core.HttpResponsePromise.fromPromise(this.__compareDatasetVersions(id, request, requestOptions));
    }

    private async __compareDatasetVersions(
        id: string,
        _request: OpikApi.CompareDatasetVersionsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetVersionDiff>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions/diff`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetVersionDiff.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/{id}/versions/diff",
        );
    }

    /**
     * Add a tag to a specific dataset version for easy reference (e.g., 'baseline', 'v1.0', 'production')
     *
     * @param {string} id
     * @param {string} versionHash
     * @param {OpikApi.DatasetVersionTag} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.datasets.createVersionTag("id", "versionHash", {
     *         tag: "tag"
     *     })
     */
    public createVersionTag(
        id: string,
        versionHash: string,
        request: OpikApi.DatasetVersionTag,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__createVersionTag(id, versionHash, request, requestOptions));
    }

    private async __createVersionTag(
        id: string,
        versionHash: string,
        request: OpikApi.DatasetVersionTag,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions/hash/${core.url.encodePathParam(versionHash)}/tags`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetVersionTag.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                case 409:
                    throw new OpikApi.ConflictError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{id}/versions/hash/{versionHash}/tags",
        );
    }

    /**
     * Remove a tag from a dataset version. The version itself is not deleted, only the tag reference.
     *
     * @param {string} id
     * @param {string} versionHash
     * @param {string} tag
     * @param {OpikApi.DeleteVersionTagRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteVersionTag("id", "versionHash", "tag")
     */
    public deleteVersionTag(
        id: string,
        versionHash: string,
        tag: string,
        request: OpikApi.DeleteVersionTagRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(
            this.__deleteVersionTag(id, versionHash, tag, request, requestOptions),
        );
    }

    private async __deleteVersionTag(
        id: string,
        versionHash: string,
        tag: string,
        _request: OpikApi.DeleteVersionTagRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions/${core.url.encodePathParam(versionHash)}/tags/${core.url.encodePathParam(tag)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.OpikApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/v1/private/datasets/{id}/versions/{versionHash}/tags/{tag}",
        );
    }

    /**
     * Get paginated list of versions for a dataset, ordered by creation time (newest first)
     *
     * @param {string} id
     * @param {OpikApi.ListDatasetVersionsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.datasets.listDatasetVersions("id")
     */
    public listDatasetVersions(
        id: string,
        request: OpikApi.ListDatasetVersionsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetVersionPagePublic> {
        return core.HttpResponsePromise.fromPromise(this.__listDatasetVersions(id, request, requestOptions));
    }

    private async __listDatasetVersions(
        id: string,
        request: OpikApi.ListDatasetVersionsRequest = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetVersionPagePublic>> {
        const { page, size } = request;
        const _queryParams: Record<string, unknown> = {
            page,
            size,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetVersionPagePublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v1/private/datasets/{id}/versions",
        );
    }

    /**
     * Restores the dataset to a previous version state by creating a new version with items copied from the specified version. If the version is already the latest, returns it as-is (no-op).
     *
     * @param {string} id
     * @param {OpikApi.DatasetVersionRestorePublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.restoreDatasetVersion("id", {
     *         versionRef: "version_ref"
     *     })
     */
    public restoreDatasetVersion(
        id: string,
        request: OpikApi.DatasetVersionRestorePublic,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetVersionPublic> {
        return core.HttpResponsePromise.fromPromise(this.__restoreDatasetVersion(id, request, requestOptions));
    }

    private async __restoreDatasetVersion(
        id: string,
        request: OpikApi.DatasetVersionRestorePublic,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetVersionPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions/restore`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetVersionRestorePublic.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetVersionPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{id}/versions/restore",
        );
    }

    /**
     * Get a specific version by its version name (e.g., 'v1', 'v373'). This is more efficient than paginating through all versions for large datasets.
     *
     * @param {string} id
     * @param {OpikApi.DatasetVersionRetrieveRequestPublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.retrieveDatasetVersion("id", {
     *         versionName: "v1"
     *     })
     */
    public retrieveDatasetVersion(
        id: string,
        request: OpikApi.DatasetVersionRetrieveRequestPublic,
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetVersionPublic> {
        return core.HttpResponsePromise.fromPromise(this.__retrieveDatasetVersion(id, request, requestOptions));
    }

    private async __retrieveDatasetVersion(
        id: string,
        request: OpikApi.DatasetVersionRetrieveRequestPublic,
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetVersionPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions/retrieve`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetVersionRetrieveRequestPublic.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetVersionPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v1/private/datasets/{id}/versions/retrieve",
        );
    }

    /**
     * Update a dataset version's change_description and/or add new tags
     *
     * @param {string} id
     * @param {string} versionHash
     * @param {OpikApi.DatasetVersionUpdatePublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.datasets.updateDatasetVersion("id", "versionHash")
     */
    public updateDatasetVersion(
        id: string,
        versionHash: string,
        request: OpikApi.DatasetVersionUpdatePublic = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): core.HttpResponsePromise<OpikApi.DatasetVersionPublic> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateDatasetVersion(id, versionHash, request, requestOptions),
        );
    }

    private async __updateDatasetVersion(
        id: string,
        versionHash: string,
        request: OpikApi.DatasetVersionUpdatePublic = {},
        requestOptions?: DatasetsClient.RequestOptions,
    ): Promise<core.WithRawResponse<OpikApi.DatasetVersionPublic>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "Comet-Workspace": requestOptions?.workspaceName ?? this._options?.workspaceName,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpikApiEnvironment.Default,
                `v1/private/datasets/${core.url.encodePathParam(id)}/versions/hash/${core.url.encodePathParam(versionHash)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.DatasetVersionUpdatePublic.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            withCredentials: true,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.DatasetVersionPublic.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpikApi.BadRequestError(_response.error.body, _response.rawResponse);
                case 404:
                    throw new OpikApi.NotFoundError(_response.error.body, _response.rawResponse);
                case 409:
                    throw new OpikApi.ConflictError(_response.error.body, _response.rawResponse);
                default:
                    throw new errors.OpikApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/v1/private/datasets/{id}/versions/hash/{versionHash}",
        );
    }
}
