---
description: Documentation standards and code style guidelines for the Python SDK
globs: sdks/python/src/opik/**/*
alwaysApply: false
---
# Python SDK Documentation and Style Guidelines

Comprehensive guidelines for writing clear, maintainable documentation and following code style standards in the Opik Python SDK.

## Type Hints

### Comprehensive Type Annotations

- **Use complete type hints** for all function signatures
- **Import typing utilities** for complex types
- **Use Union types** for multiple possible types
- **Use Optional** for nullable parameters

```python
# ✅ Good: Comprehensive type hints (from opik_client.py)
from typing import Any, Dict, List, Optional, TypeVar, Union

def search_spans(
    self,
    project_name: Optional[str] = None,
    trace_id: Optional[str] = None,
    filter_string: Optional[str] = None,
    max_results: int = 1000,
    truncate: bool = True,
) -> List[span_public.SpanPublic]:
    """Search spans with comprehensive type annotations."""
    pass

# ✅ Good: Complex type hints (from opik_usage.py)
ProviderUsage = Union[
    openai_chat_completions_usage.OpenAICompletionsUsage,
    google_usage.GoogleGeminiUsage,
    anthropic_usage.AnthropicUsage,
    bedrock_usage.BedrockUsage,
    openai_responses_usage.OpenAIResponsesUsage,
    unknown_usage.UnknownUsage,
]

# ✅ Good: Abstract method with type hints (from base_model.py)
@abc.abstractmethod
def generate_string(
    self,
    input: str,
    response_format: Optional[Type[pydantic.BaseModel]] = None,
    **kwargs: Any,
) -> str:
    """Type hints for abstract methods."""
    pass
```

### Type Variable Usage

```python
# ✅ Good: Type variable declaration (from opik_client.py)
from typing import TypeVar

T = TypeVar("T")

def process_data(self, data: T) -> T:
    """Generic type variable usage."""
    return data
```

## Docstring Standards

### Class Documentation

```python
# ✅ Good: Class docstring (from base_model.py)
class OpikBaseModel(abc.ABC):
    """
    This class serves as an interface to LLMs.

    If you want to implement custom LLM provider in evaluation metrics,
    you should inherit from this class.
    """

    def __init__(self, model_name: str):
        """
        Initializes the base model with a given model name.

        Args:
            model_name: The name of the LLM to be used.
        """
        self.model_name = model_name

# ✅ Good: Class docstring with usage details (from opik_usage.py)
class OpikUsage(pydantic.BaseModel):
    """
    A class used to convert different formats of token usage dictionaries
    into format supported by Opik ecosystem.

    `from_PROVIDER_usage_dict methods` methods are used to parse original provider's token
    usage dicts and calculate openai-formatted extra key-value pairs (that can later be used on the FE and BE sides).
    """
```

### Method Documentation

```python
# ✅ Good: Method docstring with Args (from opik_client.py)
def search_spans(
    self,
    project_name: Optional[str] = None,
    trace_id: Optional[str] = None,
    filter_string: Optional[str] = None,
    max_results: int = 1000,
    truncate: bool = True,
) -> List[span_public.SpanPublic]:
    """
    Search for spans in the given trace. This allows you to search spans based on the span input, output,
    metadata, tags, etc. or based on the trace ID.

    Args:
        project_name: The name of the project to search spans in. If not provided, will search across the project name configured when the Client was created which defaults to the `Default Project`.
        trace_id: The ID of the trace to search spans in. If provided, the search will be limited to the spans in the given trace.
        filter_string: A filter string to narrow down the search.
        max_results: The maximum number of spans to return.
        truncate: Whether to truncate image data stored in input, output, or metadata
    """
    pass

# ✅ Good: Method with Parameters and Returns (from opik_client.py)
def create_prompt(
    self,
    name: str,
    prompt: str,
    metadata: Optional[Dict[str, Any]] = None,
    type: PromptType = PromptType.MUSTACHE,
) -> Prompt:
    """
    Creates a new prompt with the given name and template.
    If a prompt with the same name already exists, it will create a new version of the existing prompt if the templates differ.

    Parameters:
        name: The name of the prompt.
        prompt: The template content of the prompt.
        metadata: Optional metadata to be included in the prompt.

    Returns:
        A Prompt object containing details of the created or retrieved prompt.

    Raises:
        ApiError: If there is an error during the creation of the prompt and the status code is not 409.
    """
    pass

# ✅ Good: Simple method docstring (from opik_client.py)
def get_trace_content(self, id: str) -> trace_public.TracePublic:
    """
    Args:
        id (str): trace id
    Returns:
        trace_public.TracePublic: pydantic model object with all the data associated with the trace found.
        Raises an error if trace was not found.
    """
    pass
```

## Comments and Code Clarity

### When to Add Comments

- **Business logic explanation**: Why certain decisions were made
- **Non-obvious behavior**: When code behavior isn't immediately clear
- **External dependencies**: Explain interactions with external systems
- **Configuration details**: Document important configuration decisions

```python
# ✅ Good: Comments explaining business logic (from configure.py)
def _configure_url(self, url_override: Optional[str]) -> None:
    # Handle URL
    base_url = url_override or self._default_base_url

    # This URL set here might not be the final one.
    # It's possible that the URL will be extracted from the smart api key on the later stage.
    # In that case `self.base_url` field will be updated.
    self.base_url = base_url

def _determine_deployment_type(self, url_override: Optional[str]) -> str:
    if url_override:
        # Step 1: If the URL is provided and active, update the configuration
        return "provided"

    # Step 2: Check if the default local instance is active
    if self._check_local_deployment():
        # Step 3: Ask user if they want to use the found local instance
        return "local"

    # Step 4: Ask user for URL if no valid local instance is found or approved
    return "cloud"
```

### Self-Documenting Code

## Sphinx & Fern Documentation Sync
- Update `apps/opik-documentation/python-sdk-docs/source/rest_api/overview.rst` (and related `.rst` files) when you add new public classes or reorganize modules in the Python SDK.
- Docstring-only adjustments or new methods on existing classes do **not** require `.rst` edits, but ensure docstrings stay accurate.
- Verify changes by running `make html` (or `sphinx-build -b html . _build/html -W --keep-going`) inside `apps/opik-documentation/python-sdk-docs`; treat warnings as failures.
- Whenever you add/remove SDK entry points, refresh the Fern docs in `apps/opik-documentation/documentation` to keep examples aligned.

## Documenting

```python
# ✅ Good: Self-explanatory code (no comments needed)
def validate_experiment_name(name: str) -> bool:
    return name and len(name.strip()) > 0 and len(name) <= 255

def build_api_client(base_url: str, api_key: str) -> OpikApi:
    return OpikApi(base_url=base_url, api_key=api_key)

# ✅ Good: Meaningful variable names
def process_llm_response(provider: LLMProvider, response_data: Dict[str, Any]) -> OpikUsage:
    usage_builders = _PROVIDER_TO_OPIK_USAGE_BUILDERS[provider]

    for build_function in usage_builders:
        try:
            return build_function(response_data)
        except Exception:
            continue

    raise ValueError(f"Failed to build usage for provider {provider}")
```

## Code Formatting Standards

### Import Organization

```python
# ✅ Good: Proper import organization (from opik_usage.py)
import logging
import pydantic
from typing import Union, Dict, Any, Optional

from . import (
    openai_chat_completions_usage,
    google_usage,
    anthropic_usage,
    unknown_usage,
    bedrock_usage,
    openai_responses_usage,
)
import opik.dict_utils as dict_utils

LOGGER = logging.getLogger(__name__)
```

### Consistent Naming

```python
# ✅ Good: Consistent naming patterns
class OpikBaseModel:          # PascalCase for classes
    def generate_string(self):  # snake_case for methods
        pass

PROVIDER_MAPPING = {}         # UPPER_CASE for constants
_private_helper = {}          # Leading underscore for private
```

## Best Practices

### Do's:
- ✅ Use comprehensive type hints for all public APIs
- ✅ Document all public classes and methods with docstrings
- ✅ Use meaningful parameter and return type descriptions
- ✅ Add comments for non-trivial business logic
- ✅ Keep code self-documenting through good naming
- ✅ Follow consistent formatting standards

### Don'ts:
- ❌ Skip type hints on public APIs
- ❌ Write obvious comments that duplicate code
- ❌ Use abbreviated or unclear names
- ❌ Leave complex logic unexplained
- ❌ Inconsistent indentation or formatting

## Key References

- [API Design Guidelines](api-design.mdc)
- [Code Structure Guidelines](code-structure.mdc)
- [Architecture Guidelines](architecture.mdc)
- [Testing Guidelines](test-organization.mdc)
