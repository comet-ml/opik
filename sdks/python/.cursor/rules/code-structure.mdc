---
description: Import organization and access control guidelines for the Python SDK
globs: sdks/python/src/opik/**/*
alwaysApply: true
---
# Python SDK Code Structure Guidelines

Comprehensive guidelines for organizing imports and implementing proper access control in the Opik Python SDK.

## Import Organization

### Import Grouping and Order

- **Always import modules, not names** (except from `typing` or similar commonly used modules)
- **Keep the namespace clean**
- **Group imports**: standard library, third-party, local imports
- **Order**: Standard library → Third-party → Local imports

```python
# ✅ Good: Proper import organization (from opik_client.py)
import atexit
import datetime
import functools
import logging
from typing import Any, Dict, List, Optional, TypeVar, Union, Literal

import httpx

from .threads import threads_client
from .. import (
    config,
    datetime_helpers,
    exceptions,
    httpx_client,
    id_helpers,
    llm_usage,
    rest_client_configurator,
    url_helpers,
)
from ..message_processing import messages, streamer_constructors, message_queue
from ..rest_api import client as rest_api_client
from ..types import ErrorInfoDict, FeedbackScoreDict, LLMProvider, SpanType

LOGGER = logging.getLogger(__name__)
```

### Module-Level Imports

```python
# ✅ Good: Import modules for cleaner namespace
import opik.exceptions as exceptions
import opik.config as config
from opik.api_objects import opik_client
from opik.message_processing.messages import (
    GuardrailBatchItemMessage,
    GuardrailBatchMessage,
)

# ❌ Bad: Importing names directly (avoid unless necessary)
from opik.exceptions import OpikException, ValidationError
from opik.config import get_from_user_inputs
```

### Typing Imports

```python
# ✅ Good: Typing imports are allowed directly
from typing import Any, Dict, List, Optional, TypeVar, Union, Literal

# ✅ Good: TYPE_CHECKING for avoiding circular imports
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from uuid import UUID
    from langchain_core.runnables.graph import Graph
    from langchain_core.messages import BaseMessage
```

## Access Control

### Protected Methods and Attributes

- **Never violate access modifiers**
- **If method/attribute is used only inside its class** - it should be protected
- **If function/object is used only inside its module** - it should be protected
- **Classes may omit underscores in names** if they are used only in their modules

```python
# ✅ Good: Protected methods for internal use
class OpikConfigurator:
    def configure(self) -> None:
        """Public API method."""
        self._configure_cloud()

    def _configure_cloud(self) -> None:
        """Private method - only used within this class."""
        api_key = self._ask_for_api_key()
        workspace = self._get_default_workspace()
        self._update_config()

    def _ask_for_api_key(self) -> str:
        """Private method - only used within this class."""
        pass

    def _update_config(self, save_to_file: bool = True) -> None:
        """Private method - only used within this class."""
        pass
```

### Module-Level Protection

```python
# ✅ Good: Protected constants and functions at module level
LOGGER = logging.getLogger(__name__)

# Constants used only within module
_DEFAULT_TIMEOUT = 30
_MAX_RETRIES = 3

def _internal_helper_function(data: Any) -> Any:
    """Private function used only within this module."""
    return data

def public_api_function(input_data: Any) -> Any:
    """Public function available to other modules."""
    return _internal_helper_function(input_data)
```

### Class Access Patterns

```python
# ✅ Good: Proper access control in classes
class Opik:
    def __init__(self, project_name: Optional[str] = None):
        """Public constructor."""
        self._project_name = project_name  # Protected attribute
        self._config = self._initialize_config()  # Protected attribute
        self._streamer = self._initialize_streamer()  # Protected attribute

    def create_experiment(self, name: str) -> Experiment:
        """Public API method."""
        return self._create_experiment_internal(name)

    def _create_experiment_internal(self, name: str) -> Experiment:
        """Protected method - used only within this class."""
        pass

    def _initialize_config(self) -> Config:
        """Protected method - used only within this class."""
        pass

    def _initialize_streamer(self) -> Streamer:
        """Protected method - used only within this class."""
        pass
```

### Integration Access Patterns

```python
# ✅ Good: Access control in integrations
class OpikTracer(BaseTracer):
    def __init__(self, project_name: Optional[str] = None):
        """Public constructor."""
        super().__init__()
        self._project_name = project_name  # Protected attribute
        self._spans_map = {}  # Protected attribute

    def _persist_run(self, run: Run) -> None:
        """Protected method - required by BaseTracer interface."""
        span_data = self._convert_run_to_span(run)
        self._update_spans_map(span_data)

    def _convert_run_to_span(self, run: Run) -> SpanData:
        """Protected method - used only within this class."""
        pass

    def _update_spans_map(self, span_data: SpanData) -> None:
        """Protected method - used only within this class."""
        pass
```

## Best Practices

### Namespace Management

```python
# ✅ Good: Clean namespace with module imports
import opik.context_storage as context_storage
import opik.opik_context as opik_context

# Usage with clear namespace
context_storage.set_trace_data(trace_data)
current_trace = opik_context.get_current_trace_data()

# ✅ Good: Aliasing for commonly used modules
from opik.api_objects import opik_client
from opik.rest_api import client as rest_api_client

# Clear distinction between different client types
opik_client_ = opik_client.Opik()
api_client_ = rest_api_client.OpikApi()
```

### Module Organization Guidelines

1. **Follow the established patterns** in the codebase
2. **Use meaningful module and class names** that reflect their purpose
3. **Keep modules focused** on single responsibilities
4. **Use consistent naming conventions** throughout the codebase

### Search Strategy for Access Patterns

**If unsure how something is used, search for examples:**

```bash
# Search in source code
grep -r "def _method_name" sdks/python/src/opik/
grep -r "class _ClassName" sdks/python/src/opik/

# Search in tests
grep -r "method_name" sdks/python/tests/
```

## Common Patterns

### Logger Declaration

```python
# ✅ Good: Standard logger pattern
import logging

LOGGER = logging.getLogger(__name__)
```

### Constants Declaration

```python
# ✅ Good: Module-level constants
from typing import Final

OPIK_BASE_URL_CLOUD: Final[str] = "https://www.comet.com/"
OPIK_BASE_URL_LOCAL: Final[str] = "http://localhost:5173/"
DEFAULT_TIMEOUT: Final[int] = 30
```

### Public API Exports

```python
# ✅ Good: Explicit __all__ declaration (from __init__.py)
__all__ = [
    "__version__",
    "Attachment",
    "evaluate",
    "evaluate_prompt",
    "evaluate_experiment",
    "track",
    "flush_tracker",
    "Opik",
    "opik_context",
    "Trace",
    "Span",
    "Dataset",
    "configure",
]
```

## Key References

- [API Design Guidelines](api-design.mdc)
- [Architecture Guidelines](architecture.mdc)
- [Error Handling Guidelines](error-handling.mdc)
- [Testing Guidelines](test-organization.mdc)
