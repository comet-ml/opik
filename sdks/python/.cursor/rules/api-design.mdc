---
description: API design principles and consistency guidelines for the Python SDK
globs: sdks/python/src/opik/**/*
alwaysApply: true
---
# Python SDK API Design Guidelines

Comprehensive guidelines for designing and implementing consistent APIs in the Opik Python SDK.

## Main API Class Usage

### Core API Pattern

- **`opik.Opik`** is the main API class - use it to create other API objects
- **High-level API**: Provide higher level API through `opik.Opik` that wraps complicated REST calls
- **Consistency**: Always look for similar APIs that already exist and make new ones consistent
- **Backward Compatibility**: Maintain backward compatibility for public interfaces

```python
# ✅ Good: Use opik.Opik as the main entry point
import opik

client = opik.Opik()
experiment = client.create_experiment(name="my_experiment")
spans = client.search_spans(project_name="my_project")

# ✅ Good: Consistent method naming patterns
client.create_experiment(name="my_experiment")
client.create_dataset(name="my_dataset")
client.get_dataset(name="my_dataset")
```

### API Object Creation

- **Factory Pattern**: Use `opik.Opik` to create other API objects
- **Consistent Parameters**: Use consistent parameter names across similar methods
- **Resource Management**: Ensure proper resource cleanup and context management

```python
# ✅ Good: Using main API class as factory
client = opik.Opik()
experiment = client.create_experiment(name="experiment_name")
dataset = client.create_dataset(name="dataset_name")

# ✅ Good: Consistent parameter patterns
client.create_experiment(name="exp1", description="desc")
client.create_dataset(name="ds1", description="desc")

# ❌ Bad: Direct instantiation bypassing main API
from opik.api_objects.experiment import Experiment
experiment = Experiment(name="test")  # Avoid this pattern
```

## API Consistency Patterns

### Method Naming Conventions

- **CRUD Operations**: Use standard create/get/list/update/delete patterns
- **Search Operations**: Use `search_*` for complex queries
- **Bulk Operations**: Use `batch_*` for bulk operations

```python
# ✅ Good: Standard CRUD patterns (actual API methods)
client.create_experiment(name="experiment")
client.get_experiment_by_id(id="experiment-id")
client.create_dataset(name="dataset")
client.get_dataset(name="dataset")

# ✅ Good: Search operations
client.search_spans(project_name="project")
client.search_traces(project_name="project")

# ❌ Bad: Inconsistent naming (avoid these patterns)
client.make_experiment(...)    # Should be create_experiment
client.fetch_dataset(...)      # Should be get_dataset
client.find_spans(...)         # Should be search_spans
```

### Parameter Consistency

- **Required vs Optional**: Keep similar parameters in the same position across methods
- **Default Values**: Only add defaults in high-level APIs, not low-level components
- **Type Hints**: Use comprehensive type hints for all public APIs

```python
# ✅ Good: Consistent parameter ordering
def create_experiment(self, name: str, description: Optional[str] = None) -> Experiment: ...
def create_dataset(self, name: str, description: Optional[str] = None) -> Dataset: ...

# ✅ Good: High-level API with defaults
def search_spans(
    self,
    project_name: Optional[str] = None,
    trace_id: Optional[str] = None,
    filter_string: Optional[str] = None,
    max_results: int = 1000,
    truncate: bool = True,
) -> List[span_public.SpanPublic]:

# ❌ Bad: Inconsistent parameter ordering
def create_experiment(self, description: str, name: str) -> Experiment: ...  # Wrong order
def create_dataset(self, name: str, desc: str) -> Dataset: ...  # Different param name
```

## Backward Compatibility

### API Evolution

- **Deprecation Strategy**: Use proper deprecation warnings for API changes
- **Version Support**: Maintain support for previous API versions during transition
- **Migration Paths**: Provide clear migration guides for breaking changes

```python
# ✅ Good: Proper deprecation pattern
from typing import Optional

LOGGER = logging.getLogger(__name__)

def old_method(self, param: str) -> str:
    LOGGER.warning("old_method is deprecated, use new_method instead")
    # Continue with existing implementation
    return param.upper()

def new_method(self, param: str) -> str:
    # New implementation with improved functionality
    return param.strip().upper()

# ✅ Good: Backward compatible parameter addition
def search_spans(
    self,
    project_name: Optional[str] = None,  # Existing parameter
    query: Optional[str] = None,         # New optional parameter
    **kwargs  # Allow for future extensions
) -> List[Span]: ...
```

### Interface Stability

- **Public vs Private**: Clearly distinguish public APIs from internal implementation
- **Return Types**: Keep return types consistent or use union types for evolution
- **Error Handling**: Maintain consistent exception types and error messages

```python
# ✅ Good: Stable public interface
class Opik:
    def create_experiment(self, name: str) -> Experiment:
        """Public API - stable interface."""
        return self._internal_create_experiment(name)
    
    def _internal_create_experiment(self, name: str) -> Experiment:
        """Internal implementation - can change."""
        pass

# ✅ Good: Consistent error handling
from opik.exceptions import OpikException, ResourceNotFoundError

def get_experiment(self, id: str) -> Experiment:
    try:
        return self._fetch_experiment(id)
    except ResourceNotFoundError:
        raise ResourceNotFoundError(f"Experiment with id '{id}' not found")
```

## Best Practices

### API Design Principles

1. **Discoverability**: Make APIs easy to discover and understand
2. **Consistency**: Follow established patterns throughout the SDK
3. **Simplicity**: Provide simple defaults while allowing complex configurations
4. **Composability**: Design APIs that work well together

### Common Patterns

```python
# ✅ Good: Simple API usage with clear parameters
client = opik.Opik(project_name="my_project")
experiment = client.create_experiment(name="experiment_1")
dataset = client.create_dataset(name="my_dataset")

# ✅ Good: Consistent parameter patterns
spans = client.search_spans(project_name="my_project")
traces = client.search_traces(project_name="my_project") 

# ✅ Good: Using @opik.track decorator for tracing
import opik

@opik.track
def my_function(input_text: str) -> str:
    return input_text.upper()
```

## Key References

- [Architecture Guidelines](architecture.mdc)
- [Error Handling Guidelines](error-handling.mdc)
- [Code Structure Guidelines](code-structure.mdc)
- [Testing Guidelines](test-organization.mdc)
