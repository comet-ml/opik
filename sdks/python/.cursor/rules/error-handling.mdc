---
description: Exception handling and error management patterns for the Python SDK
globs: sdks/python/src/opik/**/*
alwaysApply: false
---
# Python SDK Error Handling Guidelines

Comprehensive guidelines for implementing proper error handling and exception management in the Opik Python SDK.

## Exception Types and Hierarchy

### Custom Exception Classes

- **Use specific exception types** for different error categories
- **Inherit custom exceptions** from appropriate base classes in `opik.exceptions`
- **Add new exception types** when existing ones don't fit the use case
- **Raise `opik.exceptions.MetricComputationError`** from `opik.evaluation.metrics.BaseMetric` subclasses instead of hiding or masking missing data or errors

```python
# ✅ Good: Specific exception types (from exceptions.py)
class OpikException(Exception):
    """Base exception for all Opik-related errors."""
    pass

class ConfigurationError(OpikException):
    """Raised when configuration is invalid."""
    pass

class MetricComputationError(OpikException):
    """Exception raised when a metric cannot be computed."""
    pass

class GuardrailValidationFailed(OpikException):
    """Exception raised when a guardrail validation fails."""

    def __init__(
        self,
        message: str,
        validation_results: List["schemas.ValidationResult"],
        failed_validations: List["schemas.ValidationResult"],
    ):
        self.message = message
        self.validation_results = validation_results
        self.failed_validations = failed_validations
        super().__init__(message)

    def __str__(self) -> str:
        return f"{self.message}. Failed validations: {self.failed_validations}\n"
```

### Structured Exception Information

```python
# ✅ Good: Exception with structured data (from exceptions.py)
class ScoreMethodMissingArguments(OpikException):
    def __init__(
        self,
        score_name: str,
        missing_required_arguments: Sequence[str],
        available_keys: Sequence[str],
        unused_mapping_arguments: Optional[Sequence[str]] = None,
    ):
        self.score_name = score_name
        self.missing_required_arguments = missing_required_arguments
        self.available_keys = available_keys
        self.unused_mapping_arguments = unused_mapping_arguments
        super().__init__(self._get_error_message())

    def _get_error_message(self) -> str:
        message = (
            f"The scoring method {self.score_name} is missing arguments: {self.missing_required_arguments}. "
            f"These keys were not present in either the dataset item or the dictionary returned by the evaluation task. "
            f"You can either update the dataset or evaluation task to return this key or use the `scoring_key_mapping` to map existing items to the expected arguments. "
            f"The available keys found in the dataset item and evaluation task output are: {self.available_keys}. "
        )
        if self.unused_mapping_arguments:
            message += f" Some keys in `scoring_key_mapping` didn't match anything: {self.unused_mapping_arguments}"
        return message
```

## Error Handling Patterns

### Specific Exception Handling

```python
# ✅ Good: Handling specific exceptions (from message_processors.py)
def process(self, message: messages.BaseMessage) -> None:
    try:
        handler(message)
    except rest_api_core.ApiError as exception:
        if exception.status_code == 409:
            # Sometimes a retry mechanism works in a way that it sends the same request 2 times.
            # If the backend rejects the second request, we don't want users to see an error.
            return
        elif exception.status_code == 429:
            if exception.headers is not None:
                rate_limiter = rate_limit.parse_rate_limit(exception.headers)
                if rate_limiter is not None:
                    raise exceptions.OpikCloudRequestsRateLimited(
                        headers=exception.headers,
                        retry_after=rate_limiter.retry_after(),
                    )

        error_tracking_extra = _generate_error_tracking_extra(exception, message)
        LOGGER.error(
            logging_messages.FAILED_TO_PROCESS_MESSAGE_IN_BACKGROUND_STREAMER,
            message_type.__name__,
            str(exception),
            extra={"error_tracking_extra": error_tracking_extra},
        )
    except tenacity.RetryError as retry_error:
        cause = retry_error.last_attempt.exception()
        error_tracking_extra = _generate_error_tracking_extra(cause, message)
        LOGGER.error(
            logging_messages.FAILED_TO_PROCESS_MESSAGE_IN_BACKGROUND_STREAMER,
            message_type.__name__,
            f"{cause.__class__.__name__} - {cause}",
            extra={"error_tracking_extra": error_tracking_extra},
        )
    except pydantic.ValidationError as validation_error:
        error_tracking_extra = _generate_error_tracking_extra(validation_error, message)
        LOGGER.error(
            "Failed to process message: '%s' due to input data validation error:\n%s\n",
            message_type.__name__,
            validation_error,
            exc_info=True,
            extra={"error_tracking_extra": error_tracking_extra},
        )
```

## Error Information Collection

### Structured Error Information

```python
# ✅ Good: Error information collection (from error_info_collector.py)
def collect(exception: Exception) -> ErrorInfoDict:
    result: ErrorInfoDict = {
        "exception_type": type(exception).__name__,
        "traceback": "".join(
            traceback.TracebackException.from_exception(exception).format()
        ),
    }

    message = str(exception)
    if message != "":
        result["message"] = message

    return result
```

## Best Practices

### Do's:

- ✅ **Use specific exception types** for different error categories
- ✅ **Inherit from `OpikException`** for custom exceptions
- ✅ **Provide meaningful error messages** with context and solutions
- ✅ **Include structured error information** for debugging
- ✅ **Handle rate limiting** with proper retry mechanisms
- ✅ **Log errors with appropriate levels** and context
- ✅ **Use proper exception chaining** to preserve original errors

### Don'ts:

- ❌ **Don't catch generic `Exception`** without re-raising or handling appropriately
- ❌ **Don't hide or mask errors** in metric computations
- ❌ **Don't log sensitive information** in error messages
- ❌ **Don't use generic error messages** without context
- ❌ **Don't ignore transient failures** that should be retried

## Key References

- [API Design Guidelines](api-design.mdc)
- [Architecture Guidelines](architecture.mdc)
- [Code Structure Guidelines](code-structure.mdc)
- [Logging Guidelines](logging.mdc)
