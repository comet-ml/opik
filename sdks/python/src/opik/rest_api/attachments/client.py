# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.complete_multipart_upload_request_entity_type import (
    CompleteMultipartUploadRequestEntityType,
)
from ..types.multipart_upload_part import MultipartUploadPart
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unauthorized_error import UnauthorizedError
from ..core.pydantic_utilities import parse_obj_as
from ..errors.forbidden_error import ForbiddenError
from ..types.error_message import ErrorMessage
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.start_multipart_upload_request_entity_type import (
    StartMultipartUploadRequestEntityType,
)
from ..types.start_multipart_upload_response import StartMultipartUploadResponse
from .types.upload_attachment_request_entity_type import (
    UploadAttachmentRequestEntityType,
)
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AttachmentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def start_multi_part_upload(
        self,
        *,
        file_name: str,
        entity_type: CompleteMultipartUploadRequestEntityType,
        entity_id: str,
        file_size: int,
        upload_id: str,
        uploaded_file_parts: typing.Sequence[MultipartUploadPart],
        project_name: typing.Optional[str] = OMIT,
        mime_type: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        entity_type : CompleteMultipartUploadRequestEntityType

        entity_id : str

        file_size : int

        upload_id : str

        uploaded_file_parts : typing.Sequence[MultipartUploadPart]

        project_name : typing.Optional[str]
            If null, the default project is used

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from Opik import MultipartUploadPart, OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.start_multi_part_upload(
            file_name="file_name",
            entity_type="trace",
            entity_id="entity_id",
            file_size=1000000,
            upload_id="upload_id",
            uploaded_file_parts=[
                MultipartUploadPart(
                    e_tag="e_tag",
                    part_number=1,
                )
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-complete",
            method="POST",
            json={
                "file_name": file_name,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "file_size": file_size,
                "mime_type": mime_type,
                "upload_id": upload_id,
                "uploaded_file_parts": convert_and_respect_annotation_metadata(
                    object_=uploaded_file_parts,
                    annotation=typing.Sequence[MultipartUploadPart],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_multi_part_upload_1(
        self,
        *,
        file_name: str,
        num_of_file_parts: int,
        entity_type: StartMultipartUploadRequestEntityType,
        entity_id: str,
        path: str,
        mime_type: typing.Optional[str] = OMIT,
        project_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StartMultipartUploadResponse:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        num_of_file_parts : int

        entity_type : StartMultipartUploadRequestEntityType

        entity_id : str

        path : str

        mime_type : typing.Optional[str]

        project_name : typing.Optional[str]
            If null, the default project is used

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StartMultipartUploadResponse
            MultipartUploadResponse

        Examples
        --------
        from Opik import OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.start_multi_part_upload_1(
            file_name="file_name",
            num_of_file_parts=1,
            entity_type="trace",
            entity_id="entity_id",
            path="path",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-start",
            method="POST",
            json={
                "file_name": file_name,
                "num_of_file_parts": num_of_file_parts,
                "mime_type": mime_type,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "path": path,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StartMultipartUploadResponse,
                    parse_obj_as(
                        type_=StartMultipartUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_attachment(
        self,
        *,
        file_name: str,
        entity_type: UploadAttachmentRequestEntityType,
        entity_id: str,
        request: typing.Dict[str, typing.Optional[typing.Any]],
        project_name: typing.Optional[str] = None,
        mime_type: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Upload attachment to MinIO

        Parameters
        ----------
        file_name : str

        entity_type : UploadAttachmentRequestEntityType

        entity_id : str

        request : typing.Dict[str, typing.Optional[typing.Any]]

        project_name : typing.Optional[str]

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from Opik import OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.upload_attachment(
            file_name="file_name",
            entity_type="trace",
            entity_id="entity_id",
            request={"key": "value"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload",
            method="PUT",
            params={
                "file_name": file_name,
                "project_name": project_name,
                "mime_type": mime_type,
                "entity_type": entity_type,
                "entity_id": entity_id,
            },
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAttachmentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def start_multi_part_upload(
        self,
        *,
        file_name: str,
        entity_type: CompleteMultipartUploadRequestEntityType,
        entity_id: str,
        file_size: int,
        upload_id: str,
        uploaded_file_parts: typing.Sequence[MultipartUploadPart],
        project_name: typing.Optional[str] = OMIT,
        mime_type: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        entity_type : CompleteMultipartUploadRequestEntityType

        entity_id : str

        file_size : int

        upload_id : str

        uploaded_file_parts : typing.Sequence[MultipartUploadPart]

        project_name : typing.Optional[str]
            If null, the default project is used

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi, MultipartUploadPart

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.start_multi_part_upload(
                file_name="file_name",
                entity_type="trace",
                entity_id="entity_id",
                file_size=1000000,
                upload_id="upload_id",
                uploaded_file_parts=[
                    MultipartUploadPart(
                        e_tag="e_tag",
                        part_number=1,
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-complete",
            method="POST",
            json={
                "file_name": file_name,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "file_size": file_size,
                "mime_type": mime_type,
                "upload_id": upload_id,
                "uploaded_file_parts": convert_and_respect_annotation_metadata(
                    object_=uploaded_file_parts,
                    annotation=typing.Sequence[MultipartUploadPart],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_multi_part_upload_1(
        self,
        *,
        file_name: str,
        num_of_file_parts: int,
        entity_type: StartMultipartUploadRequestEntityType,
        entity_id: str,
        path: str,
        mime_type: typing.Optional[str] = OMIT,
        project_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StartMultipartUploadResponse:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        num_of_file_parts : int

        entity_type : StartMultipartUploadRequestEntityType

        entity_id : str

        path : str

        mime_type : typing.Optional[str]

        project_name : typing.Optional[str]
            If null, the default project is used

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StartMultipartUploadResponse
            MultipartUploadResponse

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.start_multi_part_upload_1(
                file_name="file_name",
                num_of_file_parts=1,
                entity_type="trace",
                entity_id="entity_id",
                path="path",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-start",
            method="POST",
            json={
                "file_name": file_name,
                "num_of_file_parts": num_of_file_parts,
                "mime_type": mime_type,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "path": path,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StartMultipartUploadResponse,
                    parse_obj_as(
                        type_=StartMultipartUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_attachment(
        self,
        *,
        file_name: str,
        entity_type: UploadAttachmentRequestEntityType,
        entity_id: str,
        request: typing.Dict[str, typing.Optional[typing.Any]],
        project_name: typing.Optional[str] = None,
        mime_type: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Upload attachment to MinIO

        Parameters
        ----------
        file_name : str

        entity_type : UploadAttachmentRequestEntityType

        entity_id : str

        request : typing.Dict[str, typing.Optional[typing.Any]]

        project_name : typing.Optional[str]

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.upload_attachment(
                file_name="file_name",
                entity_type="trace",
                entity_id="entity_id",
                request={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload",
            method="PUT",
            params={
                "file_name": file_name,
                "project_name": project_name,
                "mime_type": mime_type,
                "entity_type": entity_type,
                "entity_id": entity_id,
            },
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
