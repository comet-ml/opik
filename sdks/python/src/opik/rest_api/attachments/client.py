# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.attachment_list_request_entity_type import AttachmentListRequestEntityType
from ..core.request_options import RequestOptions
from ..types.attachment_page import AttachmentPage
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.forbidden_error import ForbiddenError
from ..types.error_message import ErrorMessage
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.complete_multipart_upload_request_entity_type import (
    CompleteMultipartUploadRequestEntityType,
)
from ..types.multipart_upload_part import MultipartUploadPart
from ..core.serialization import convert_and_respect_annotation_metadata
from .types.download_attachment_request_entity_type import (
    DownloadAttachmentRequestEntityType,
)
from .types.start_multipart_upload_request_entity_type import (
    StartMultipartUploadRequestEntityType,
)
from ..types.start_multipart_upload_response import StartMultipartUploadResponse
from .types.upload_attachment_request_entity_type import (
    UploadAttachmentRequestEntityType,
)
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AttachmentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def attachment_list(
        self,
        *,
        project_id: str,
        entity_type: AttachmentListRequestEntityType,
        entity_id: str,
        path: str,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AttachmentPage:
        """
        Attachments list for entity

        Parameters
        ----------
        project_id : str

        entity_type : AttachmentListRequestEntityType

        entity_id : str

        path : str

        page : typing.Optional[int]

        size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AttachmentPage
            Attachment Resource

        Examples
        --------
        from Opik import OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.attachment_list(
            project_id="project_id",
            entity_type="trace",
            entity_id="entity_id",
            path="path",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/list",
            method="GET",
            params={
                "page": page,
                "size": size,
                "project_id": project_id,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "path": path,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AttachmentPage,
                    parse_obj_as(
                        type_=AttachmentPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_multi_part_upload(
        self,
        *,
        file_name: str,
        entity_type: CompleteMultipartUploadRequestEntityType,
        entity_id: str,
        file_size: int,
        upload_id: str,
        uploaded_file_parts: typing.Sequence[MultipartUploadPart],
        project_name: typing.Optional[str] = OMIT,
        mime_type: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        entity_type : CompleteMultipartUploadRequestEntityType

        entity_id : str

        file_size : int

        upload_id : str

        uploaded_file_parts : typing.Sequence[MultipartUploadPart]

        project_name : typing.Optional[str]
            If null, the default project is used

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from Opik import MultipartUploadPart, OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.start_multi_part_upload(
            file_name="file_name",
            entity_type="trace",
            entity_id="entity_id",
            file_size=1000000,
            upload_id="upload_id",
            uploaded_file_parts=[
                MultipartUploadPart(
                    e_tag="e_tag",
                    part_number=1,
                )
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-complete",
            method="POST",
            json={
                "file_name": file_name,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "file_size": file_size,
                "mime_type": mime_type,
                "upload_id": upload_id,
                "uploaded_file_parts": convert_and_respect_annotation_metadata(
                    object_=uploaded_file_parts,
                    annotation=typing.Sequence[MultipartUploadPart],
                    direction="write",
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def download_attachment(
        self,
        *,
        container_id: str,
        entity_type: DownloadAttachmentRequestEntityType,
        entity_id: str,
        file_name: str,
        mime_type: str,
        workspace_name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Download attachment from MinIO

        Parameters
        ----------
        container_id : str

        entity_type : DownloadAttachmentRequestEntityType

        entity_id : str

        file_name : str

        mime_type : str

        workspace_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]
            Attachment Resource
        """
        with self._client_wrapper.httpx_client.stream(
            "v1/private/attachment/download",
            method="GET",
            params={
                "workspace_name": workspace_name,
                "container_id": container_id,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "file_name": file_name,
                "mime_type": mime_type,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = (
                        request_options.get("chunk_size", None)
                        if request_options is not None
                        else None
                    )
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(
                            ErrorMessage,
                            parse_obj_as(
                                type_=ErrorMessage,  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def start_multi_part_upload_1(
        self,
        *,
        file_name: str,
        num_of_file_parts: int,
        entity_type: StartMultipartUploadRequestEntityType,
        entity_id: str,
        path: str,
        mime_type: typing.Optional[str] = OMIT,
        project_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StartMultipartUploadResponse:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        num_of_file_parts : int

        entity_type : StartMultipartUploadRequestEntityType

        entity_id : str

        path : str

        mime_type : typing.Optional[str]

        project_name : typing.Optional[str]
            If null, the default project is used

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StartMultipartUploadResponse
            MultipartUploadResponse

        Examples
        --------
        from Opik import OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.start_multi_part_upload_1(
            file_name="file_name",
            num_of_file_parts=1,
            entity_type="trace",
            entity_id="entity_id",
            path="path",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-start",
            method="POST",
            json={
                "file_name": file_name,
                "num_of_file_parts": num_of_file_parts,
                "mime_type": mime_type,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "path": path,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StartMultipartUploadResponse,
                    parse_obj_as(
                        type_=StartMultipartUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_attachment(
        self,
        *,
        file_name: str,
        entity_type: UploadAttachmentRequestEntityType,
        entity_id: str,
        request: typing.Dict[str, typing.Optional[typing.Any]],
        project_name: typing.Optional[str] = None,
        mime_type: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Upload attachment to MinIO

        Parameters
        ----------
        file_name : str

        entity_type : UploadAttachmentRequestEntityType

        entity_id : str

        request : typing.Dict[str, typing.Optional[typing.Any]]

        project_name : typing.Optional[str]

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from Opik import OpikApi

        client = OpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )
        client.attachments.upload_attachment(
            file_name="file_name",
            entity_type="trace",
            entity_id="entity_id",
            request={"key": "value"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload",
            method="PUT",
            params={
                "file_name": file_name,
                "project_name": project_name,
                "mime_type": mime_type,
                "entity_type": entity_type,
                "entity_id": entity_id,
            },
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAttachmentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def attachment_list(
        self,
        *,
        project_id: str,
        entity_type: AttachmentListRequestEntityType,
        entity_id: str,
        path: str,
        page: typing.Optional[int] = None,
        size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AttachmentPage:
        """
        Attachments list for entity

        Parameters
        ----------
        project_id : str

        entity_type : AttachmentListRequestEntityType

        entity_id : str

        path : str

        page : typing.Optional[int]

        size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AttachmentPage
            Attachment Resource

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.attachment_list(
                project_id="project_id",
                entity_type="trace",
                entity_id="entity_id",
                path="path",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/list",
            method="GET",
            params={
                "page": page,
                "size": size,
                "project_id": project_id,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "path": path,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AttachmentPage,
                    parse_obj_as(
                        type_=AttachmentPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_multi_part_upload(
        self,
        *,
        file_name: str,
        entity_type: CompleteMultipartUploadRequestEntityType,
        entity_id: str,
        file_size: int,
        upload_id: str,
        uploaded_file_parts: typing.Sequence[MultipartUploadPart],
        project_name: typing.Optional[str] = OMIT,
        mime_type: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        entity_type : CompleteMultipartUploadRequestEntityType

        entity_id : str

        file_size : int

        upload_id : str

        uploaded_file_parts : typing.Sequence[MultipartUploadPart]

        project_name : typing.Optional[str]
            If null, the default project is used

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi, MultipartUploadPart

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.start_multi_part_upload(
                file_name="file_name",
                entity_type="trace",
                entity_id="entity_id",
                file_size=1000000,
                upload_id="upload_id",
                uploaded_file_parts=[
                    MultipartUploadPart(
                        e_tag="e_tag",
                        part_number=1,
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-complete",
            method="POST",
            json={
                "file_name": file_name,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "file_size": file_size,
                "mime_type": mime_type,
                "upload_id": upload_id,
                "uploaded_file_parts": convert_and_respect_annotation_metadata(
                    object_=uploaded_file_parts,
                    annotation=typing.Sequence[MultipartUploadPart],
                    direction="write",
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def download_attachment(
        self,
        *,
        container_id: str,
        entity_type: DownloadAttachmentRequestEntityType,
        entity_id: str,
        file_name: str,
        mime_type: str,
        workspace_name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Download attachment from MinIO

        Parameters
        ----------
        container_id : str

        entity_type : DownloadAttachmentRequestEntityType

        entity_id : str

        file_name : str

        mime_type : str

        workspace_name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]
            Attachment Resource
        """
        async with self._client_wrapper.httpx_client.stream(
            "v1/private/attachment/download",
            method="GET",
            params={
                "workspace_name": workspace_name,
                "container_id": container_id,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "file_name": file_name,
                "mime_type": mime_type,
            },
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = (
                        request_options.get("chunk_size", None)
                        if request_options is not None
                        else None
                    )
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(
                            ErrorMessage,
                            parse_obj_as(
                                type_=ErrorMessage,  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def start_multi_part_upload_1(
        self,
        *,
        file_name: str,
        num_of_file_parts: int,
        entity_type: StartMultipartUploadRequestEntityType,
        entity_id: str,
        path: str,
        mime_type: typing.Optional[str] = OMIT,
        project_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StartMultipartUploadResponse:
        """
        Start multipart attachment upload

        Parameters
        ----------
        file_name : str

        num_of_file_parts : int

        entity_type : StartMultipartUploadRequestEntityType

        entity_id : str

        path : str

        mime_type : typing.Optional[str]

        project_name : typing.Optional[str]
            If null, the default project is used

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StartMultipartUploadResponse
            MultipartUploadResponse

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.start_multi_part_upload_1(
                file_name="file_name",
                num_of_file_parts=1,
                entity_type="trace",
                entity_id="entity_id",
                path="path",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload-start",
            method="POST",
            json={
                "file_name": file_name,
                "num_of_file_parts": num_of_file_parts,
                "mime_type": mime_type,
                "project_name": project_name,
                "entity_type": entity_type,
                "entity_id": entity_id,
                "path": path,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StartMultipartUploadResponse,
                    parse_obj_as(
                        type_=StartMultipartUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_attachment(
        self,
        *,
        file_name: str,
        entity_type: UploadAttachmentRequestEntityType,
        entity_id: str,
        request: typing.Dict[str, typing.Optional[typing.Any]],
        project_name: typing.Optional[str] = None,
        mime_type: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Upload attachment to MinIO

        Parameters
        ----------
        file_name : str

        entity_type : UploadAttachmentRequestEntityType

        entity_id : str

        request : typing.Dict[str, typing.Optional[typing.Any]]

        project_name : typing.Optional[str]

        mime_type : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from Opik import AsyncOpikApi

        client = AsyncOpikApi(
            api_key="YOUR_API_KEY",
            workspace_name="YOUR_WORKSPACE_NAME",
        )


        async def main() -> None:
            await client.attachments.upload_attachment(
                file_name="file_name",
                entity_type="trace",
                entity_id="entity_id",
                request={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/private/attachment/upload",
            method="PUT",
            params={
                "file_name": file_name,
                "project_name": project_name,
                "mime_type": mime_type,
                "entity_type": entity_type,
                "entity_id": entity_id,
            },
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
