---
description: Code Style guidelines
globs: apps/opik-backend/**/*
alwaysApply: false
---
# Backend Java Code Style Guidelines

## Comment Hygiene

### Clean Up Unused Code

**Rule**: Remove commented-out constants and unused field declarations instead of leaving them in the codebase.

```java
// ❌ BAD: Leaving commented-out sensitive field
private static final String WEBHOOK_URL_DB = "webhook_url";
// private static final String WEBHOOK_SECRET_TOKEN_DB = "webhook_secret_token"; // Don't expose

// ✅ GOOD: Just remove it completely
private static final String WEBHOOK_URL_DB = "webhook_url";
// Webhook secret token is intentionally not included for security reasons
```

**When to keep comments**:
- Explaining WHY something was removed (in PR description)
- Documenting business decisions
- Clarifying non-obvious security constraints

## Method Parameter Formatting

### Consistent Parameter Alignment

For methods with multiple parameters, use consistent line breaks:

```java
// ✅ GOOD: Each parameter on its own line when breaking
public Response find(
        @QueryParam("project_id") UUID projectId,
        @QueryParam("id") 
        @Schema(description = "Filter by rule ID (partial match)") 
        String id,
        @QueryParam("filters") String filters,
        @QueryParam("sorting") String sorting,
        @QueryParam("page") @DefaultValue("1") int page,
        @QueryParam("size") @DefaultValue("10") int size) {
    // method body
}
```

## Enum and Map Initialization

### ImmutableMap Patterns

Use consistent formatting for map initialization:

```java
// ✅ GOOD: Consistent formatting with clear structure
private static final Map<Field, String> FIELD_MAP = new EnumMap<>(
    ImmutableMap.<Field, String>builder()
        .put(Field.ID, RULE_PREFIX.formatted(ID_DB))
        .put(Field.NAME, RULE_PREFIX.formatted(NAME_DB))
        .put(Field.TYPE, EVALUATOR_PREFIX.formatted(TYPE_DB))
        .build());
```

## Import Statements

### Use Imports Instead of Inline Fully-Qualified Class Names

**Rule**: Always use import statements at the top of the file instead of inline fully-qualified class names, unless there is a name collision.

```java
// ❌ BAD: Using inline fully-qualified class name
public void processMessage(String message) {
    lenient().when(stream.listPending(any(org.redisson.api.stream.StreamPendingRangeArgs.class)))
        .thenReturn(Mono.just(List.of()));
}

// ✅ GOOD: Using import statement
import org.redisson.api.stream.StreamPendingRangeArgs;

public void processMessage(String message) {
    lenient().when(stream.listPending(any(StreamPendingRangeArgs.class)))
        .thenReturn(Mono.just(List.of()));
}
```

**Exception - Name Collision**: Only use fully-qualified names when there's a naming conflict:

```java
// ✅ ACCEPTABLE: When two classes have the same name
import com.comet.opik.api.User;

public void processUsers(com.external.lib.User externalUser, User internalUser) {
    // Both User classes needed, one must be fully-qualified
}
```

## Prefer Shared Helpers

**Rule**: Always use existing utility classes and helper methods instead of re-implementing common patterns. This ensures consistency, reduces duplication, and leverages properly configured shared instances.

### String Validation

Use Apache Commons `StringUtils` for null-safe string checks:

```java
// ❌ BAD: Manual null checks and empty string validation
if (value == null || value.isEmpty() || value.trim().isEmpty()) {
    // handle blank
}

// ✅ GOOD: Use StringUtils for null-safe checks
import org.apache.commons.lang3.StringUtils;

if (StringUtils.isBlank(value)) {
    // handle blank
}

if (StringUtils.isNotBlank(provider)) {
    // use provider
}
```

**When to use**:
- `StringUtils.isBlank()`: Checks for null, empty, or whitespace-only strings
- `StringUtils.isNotBlank()`: Inverse of `isBlank()` - returns true for non-null, non-empty, non-whitespace strings
- Use throughout the codebase for mode/provider parsing, field validation, and conditional logic

### JSON Processing

Use `JsonUtils` for all JSON operations instead of creating new `ObjectMapper` instances:

```java
// ❌ BAD: Creating new ObjectMapper instances
ObjectMapper mapper = new ObjectMapper();
JsonNode node = mapper.readTree(jsonString);

// ✅ GOOD: Use shared JsonUtils
import com.comet.opik.utils.JsonUtils;

JsonNode node = JsonUtils.getJsonNodeFromString(jsonString);
String json = JsonUtils.writeValueAsString(object);
ObjectNode objNode = JsonUtils.createObjectNode();
```

**Why**: `JsonUtils` provides a centrally configured `ObjectMapper` that:
- Matches Dropwizard's configuration (snake_case naming, date handling, etc.)
- Respects `config.yml` settings for stream read constraints
- Includes custom deserializers (BigDecimal, Message, Duration)
- Ensures consistent JSON processing across the application

**Exceptions**:
- **Tests**: Creating `new ObjectMapper()` in test classes is acceptable when testing serialization/deserialization behavior
- **Infrastructure classes**: Classes like `JsonNodeArgumentFactory` that need isolated instances for specific use cases

### Factory Methods for Default Values

When classes need default or "empty" instances, provide static factory methods:

```java
// ✅ GOOD: Factory method for empty/default instance
@Builder(toBuilder = true)
public record ModelPrice(
    @NonNull BigDecimal inputPrice,
    @NonNull BigDecimal outputPrice,
    // ... other fields
) {
    public static ModelPrice empty() {
        return new ModelPrice(
            BigDecimal.ZERO,
            BigDecimal.ZERO,
            // ... zeroed values
        );
    }
}

// Usage
ModelPrice price = ModelPrice.empty();
```

**Benefits**:
- Single source of truth for default values
- Clear intent when creating empty instances
- Easier to maintain if default values change
- Works well with `@Builder(toBuilder = true)` for immutable updates

### Other Utility Classes

The codebase provides several utility classes for common operations:

- **`ValidationUtils`**: Validation constants and patterns (e.g., `NULL_OR_NOT_BLANK`, `COMMIT_PATTERN`)
- **`ErrorUtils`**: Standardized error creation (e.g., `failWithNotFound()`)
- **`TruncationUtils`**: JSON node processing with truncation handling
- **`PaginationUtils`**: Pagination-related utilities

Always check existing utilities before implementing similar functionality.

## Benefits

- **Consistency**: Shared helpers ensure uniform behavior across the codebase
- **Maintainability**: Changes to common patterns only need to be made in one place
- **Configuration**: Shared instances (like `JsonUtils.getMapper()`) respect application configuration
- **Readability**: Utility methods have clear, descriptive names that improve code clarity
- **Performance**: Reusing configured instances avoids unnecessary object creation

## Related Rules

- [Code Quality Guidelines](mdc:apps/opik-backend/.cursor/rules/code_quality.mdc)
- [General Guidelines](mdc:apps/opik-backend/.cursor/rules/general.mdc)
