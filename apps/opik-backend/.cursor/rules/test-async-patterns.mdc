---
description: Test Async Patterns
globs: apps/opik-backend/**/*
alwaysApply: false
---
# Backend Test Async and Timing Patterns

## Avoid Awaitility in Synchronous Tests

### Rule: Don't Use Awaitility for MySQL Synchronous Operations

**Background**: Awaitility should only be used when dealing with truly asynchronous operations. MySQL operations in Opik backend tests are synchronous and transactional.

### ❌ BAD: Using Awaitility for Synchronous Operations

```java
// When testing MySQL-based CRUD operations that are synchronous
evaluatorsResourceClient.createEvaluator(evaluator, WORKSPACE_NAME, API_KEY);

// ❌ BAD: Unnecessary Awaitility for synchronous data
Awaitility.await().pollInterval(500, TimeUnit.MILLISECONDS).untilAsserted(() -> {
    var page = evaluatorsResourceClient.findEvaluatorPage(
        projectId, null, null, sorting, 1, 10, WORKSPACE_NAME, API_KEY);
    
    assertThat(page.content()).hasSizeGreaterThanOrEqualTo(5);
    // assertions...
});
```

### ✅ GOOD: Direct Assertions for Synchronous Operations

```java
// Create data synchronously
evaluatorsResourceClient.createEvaluator(evaluator, WORKSPACE_NAME, API_KEY);

// Direct query - no waiting needed
var page = evaluatorsResourceClient.findEvaluatorPage(
    projectId, null, null, sorting, 1, 10, WORKSPACE_NAME, API_KEY);

// Direct assertions
assertThat(page.content()).hasSize(5);
assertThat(page.content()).isSortedAccordingTo(comparator);
```

## When to Use Awaitility

### Use Awaitility Only For:

1. **Asynchronous Message Processing**: Kafka consumers, message queues
2. **Background Jobs**: Scheduled tasks, async processors
3. **External Service Polling**: Waiting for external system state changes
4. **Event-Driven Systems**: Waiting for event propagation

### Example: Valid Awaitility Usage

```java
// ✅ GOOD: Waiting for async Kafka message processing
kafkaProducer.send(message);

Awaitility.await()
    .atMost(5, TimeUnit.SECONDS)
    .pollInterval(100, TimeUnit.MILLISECONDS)
    .untilAsserted(() -> {
        var processed = repository.findProcessedMessage(message.getId());
        assertThat(processed).isNotNull();
    });
```

## Alternative to Thread.sleep()

### Avoid Thread.sleep() in Tests

**Rule**: Instead of using `Thread.sleep()` to create time gaps, use timestamp manipulation or Instant-based approaches.

### ❌ BAD: Using Thread.sleep()

```java
// Create first entity
var entity1 = client.create(data1);

var timestamp = Instant.now();
Thread.sleep(1000); // ❌ Slows down tests

// Create second entity
var entity2 = client.create(data2);

// Filter by timestamp
var results = client.findAfter(timestamp);
```

### ✅ GOOD: Use Timestamp Manipulation or Controlled Data

```java
// Option 1: Use explicit timestamps in test data
var timestamp1 = Instant.now().minusSeconds(10);
var timestamp2 = Instant.now();

var entity1 = Entity.builder()
    .createdAt(timestamp1)
    .build();
var entity2 = Entity.builder()
    .createdAt(timestamp2)
    .build();

// Option 2: Accept small time differences and use millis precision
var timestampBefore = Instant.now();
var entity1 = client.create(data1);
var entity2 = client.create(data2);

// Most database timestamps have enough precision
var results = client.findAfter(timestampBefore);
assertThat(results).contains(entity1, entity2);
```

## Troubleshooting Test Timing Issues

### If Tests Pass Locally But Fail in CI

**Symptoms**: Tests pass on local machine but fail in GitHub Actions or CI environment.

**Common Causes**:
1. **Race conditions**: Test assumes synchronous behavior but operation is async
2. **Database replication lag**: Using read replicas with replication delay
3. **Resource contention**: CI has slower CPU/memory causing timing issues

**Solutions**:

```java
// ❌ BAD: Assuming instant database consistency in replicated setup
entity.create();
var result = entity.find(); // May fail if replica is lagging

// ✅ GOOD: If replication exists, add appropriate wait with timeout
entity.create();

if (hasReplication()) {
    Awaitility.await()
        .atMost(2, TimeUnit.SECONDS)
        .untilAsserted(() -> {
            var result = entity.find();
            assertThat(result).isNotNull();
        });
} else {
    var result = entity.find();
    assertThat(result).isNotNull();
}
```

### Investigation Checklist

When tests fail inconsistently in CI:

- [ ] Check if database has replication configured
- [ ] Verify database connection is not using eventual consistency
- [ ] Review if caching layer could cause stale reads
- [ ] Examine if test uses fire-and-forget async patterns
- [ ] Look for race conditions in concurrent test execution

## Test Performance Considerations

### Keep Tests Fast

- **Avoid Awaitility** unless absolutely necessary (adds minimum 100-500ms per poll)
- **No Thread.sleep()** - wastes time and makes tests slower
- **Use Transactional Tests** - rollback after each test for isolation
- **Parallel Execution** - ensure tests can run in parallel safely

### Example: Fast Test Pattern

```java
@Test
void testSorting() {
    // Arrange: Create test data (synchronous, fast)
    var entities = IntStream.range(0, 5)
        .mapToObj(i -> factory.manufacturePojo(Entity.class))
        .toList();
    entities.forEach(client::create);
    
    // Act: Execute query (synchronous, returns immediately)
    var page = client.findSorted("name", "ASC");
    
    // Assert: Verify results (no waiting needed)
    assertThat(page.content())
        .extracting(Entity::getName)
        .isSorted();
}
```

## Related Rules

- [Testing Guidelines](mdc:apps/opik-backend/.cursor/rules/testing.mdc)
- [MySQL Transaction Patterns](mdc:apps/opik-backend/.cursor/rules/mysql.mdc)
