---
description: General guidelines for making changes in Opik backend
globs: **/*.java
alwaysApply: true
---

# General Development Guidelines

Comprehensive guidelines for making changes in the Opik backend following established patterns and conventions.

## Architecture Principles

### **Layered Architecture**

Follow the established layered architecture pattern:

```
Resources → Services → DAOs → Models
```

**Layer Responsibilities:**

- **Resources**: Handle HTTP requests/responses, input validation, response formatting
- **Services**: Implement business logic, orchestrate operations
- **DAOs**: Handle data persistence and retrieval, database operations
- **Models**: Data structures reflecting database or business entities

### **File Placement Guidelines**

When creating new components, place them in the correct layer:

```java
// Resources (API Layer)
src/main/java/com/comet/opik/api/resources/v1/
├── UsersResource.java
├── ProjectsResource.java
└── TracesResource.java

// Services (Business Logic)
src/main/java/com/comet/opik/domain/
├── UserService.java
├── ProjectService.java
└── TraceService.java

// DAOs (Data Access)
src/main/java/com/comet/opik/domain/
├── UserDao.java
├── ProjectDao.java
└── TraceDao.java

// Models (Data Structures)
src/main/java/com/comet/opik/api/
├── User.java
├── Project.java
└── Trace.java
```

## Code Quality Standards

### **File Formatting**

- **All files must end with a blank line**
- **Use consistent indentation** (4 spaces)
- **Follow Java naming conventions**
- **Use meaningful variable and method names**

### **Code Review Process**

Before implementing new features:

1. **Review 3 similar classes** to align with existing patterns
2. **Check existing implementations** for consistent naming
3. **Follow established conventions** for annotations and structure
4. **Use existing utility classes** when available

### **Example: Creating a New Resource**

```java
// 1. Review existing resources
// apps/opik-backend/src/main/java/com/comet/opik/api/resources/v1/

// 2. Follow established patterns
@Path("/api/v1/entities")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class EntitiesResource {

    private final @NonNull EntityService entityService;

    @GET
    public Response getEntities(
        @QueryParam("page") @Min(1) @DefaultValue("1") int page,
        @QueryParam("size") @Min(1) @DefaultValue("10") int size
    ) {
        var entities = entityService.getEntities(page, size);
        return Response.ok(entities).build();
    }

    @POST
    public Response createEntity(@Valid EntityCreateRequest request) {
        var entity = entityService.createEntity(request);
        return Response.status(Response.Status.CREATED)
            .entity(entity)
            .build();
    }
}
```

## Development Workflow

### **Before Making Changes**

1. **Understand the existing codebase**:
   - Review similar implementations
   - Check existing patterns and conventions
   - Understand the layered architecture

2. **Plan your implementation**:
   - Identify which layer(s) need changes
   - Consider the impact on existing code
   - Plan for proper error handling

3. **Follow established patterns**:
   - Use existing annotations and patterns
   - Follow naming conventions
   - Implement proper validation

### **During Implementation**

1. **Create components in the correct layer**:
   - Resources for API endpoints
   - Services for business logic
   - DAOs for data access
   - Models for data structures

2. **Use proper dependency injection**:

   ```java
   @Singleton
   @RequiredArgsConstructor(onConstructor_ = @Inject)
   public class EntityService {
       private final @NonNull EntityDao entityDao;
       private final @NonNull IdGenerator idGenerator;
   }
   ```

3. **Implement proper validation**:

   ```java
   @Valid
   @NotNull(message = "Name is required")
   private String name;
   ```

### **After Implementation**

1. **Verify code compiles** (skip tests for compilation check):

   ```bash
   mvn compile -DskipTests
   ```

2. **Run tests** to ensure functionality:

   ```bash
   mvn test
   ```

3. **Check code formatting**:

   ```bash
   mvn spotless:check
   ```

## Testing Guidelines

### **Test Organization**

- **Unit tests**: Test individual components in isolation
- **Integration tests**: Test component interactions
- **End-to-end tests**: Test complete workflows

### **Test Naming Conventions**

```java
@Test
void shouldCreateEntity_whenValidRequest() {
    // Test implementation
}

@Test
void shouldThrowBadRequestException_whenInvalidInput() {
    // Test implementation
}
```

### **Test Data Generation**

Use PODAM for generating test data:

```java
@Autowired
private PodamFactory podamFactory;

@Test
void shouldCreateEntity_whenValidRequest() {
    // Given
    var request = podamFactory.manufacturePojo(EntityCreateRequest.class);
    
    // When
    var result = entityService.createEntity(request);
    
    // Then
    assertThat(result).isNotNull();
}
```

## Common Patterns

### **Service Layer Pattern**

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class EntityService {
    
    private final @NonNull EntityDao entityDao;
    private final @NonNull IdGenerator idGenerator;
    private final @NonNull TransactionTemplate transactionTemplate;

    public EntityResponse createEntity(EntityCreateRequest request) {
        return transactionTemplate.inTransaction(WRITE, handle -> {
            var repository = handle.attach(EntityDao.class);
            
            var entity = Entity.builder()
                .id(idGenerator.generate())
                .name(request.getName())
                .createdAt(Instant.now())
                .build();
            
            return repository.create(entity);
        });
    }
}
```

### **DAO Layer Pattern**

```java
@RegisterRowMapper(EntityRowMapper.class)
public interface EntityDao {
    
    @SqlQuery("SELECT * FROM entities WHERE id = :id")
    Optional<Entity> findById(@Bind("id") String id);
    
    @SqlUpdate("INSERT INTO entities (id, name, created_at) VALUES (:id, :name, :createdAt)")
    @GetGeneratedKeys
    Entity create(@BindBean Entity entity);
}
```

## Best Practices

### **Do's:**

- ✅ Follow the layered architecture
- ✅ Review existing similar implementations
- ✅ Use proper dependency injection
- ✅ Implement proper validation
- ✅ Add comprehensive tests
- ✅ Follow naming conventions
- ✅ End files with blank lines

### **Don'ts:**

- ❌ Skip the layered architecture
- ❌ Create components in wrong layers
- ❌ Ignore existing patterns
- ❌ Skip validation
- ❌ Forget to add tests
- ❌ Use inconsistent naming

## Key References

- [API Design Guidelines](mdc:apps/opik-backend/.cursor/rules/api_design.mdc)
- [Architecture Guidelines](mdc:apps/opik-backend/.cursor/rules/architecture.mdc)
- [Business Logic Guidelines](mdc:apps/opik-backend/.cursor/rules/business_logic.mdc)
- [Error Handling Guidelines](mdc:apps/opik-backend/.cursor/rules/error_handling.mdc)
- [Testing Guidelines](mdc:apps/opik-backend/.cursor/rules/testing.mdc)
