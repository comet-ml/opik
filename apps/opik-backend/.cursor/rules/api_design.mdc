---
description: API Design Guidelines
globs: apps/opik-backend/**/*
alwaysApply: false
---

# API Design Guidelines

Comprehensive guidelines for designing and implementing REST APIs in the Opik backend.

## Top Level Guidelines

- Define REST endpoints clearly and document them
- Ensure DTOs are consistent with existing models and naming patterns
- use @Valid and Jakarta validations
- use Swagger annotations to document APIs
- use JsonView annotations to control serialization

## REST Endpoint Design

### Standard REST Patterns

1. **Use proper HTTP methods**:
   - `GET` for retrieving resources
   - `POST` for creating new resources
   - `PUT` for full updates
   - `PATCH` for partial updates
   - `DELETE` for removing resources

2. **Follow consistent URL patterns**:

   ```
   GET    /api/v1/resources          # List resources
   POST   /api/v1/resources          # Create resource
   GET    /api/v1/resources/{id}     # Get specific resource
   PUT    /api/v1/resources/{id}     # Update resource
   DELETE /api/v1/resources/{id}     # Delete resource
   ```

3. **Use proper HTTP status codes**:
   - `200 OK` - Successful GET, PUT, PATCH
   - `201 Created` - Successful POST
   - `204 No Content` - Successful DELETE
   - `400 Bad Request` - Invalid input
   - `401 Unauthorized` - Authentication required
   - `403 Forbidden` - Insufficient permissions
   - `404 Not Found` - Resource not found
   - `500 Internal Server Error` - Server error

## Resource Implementation

### Controller Structure

```java
@Path("/api/v1/resources")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourcesResource {

    private final @NonNull ResourceService resourceService;

    @GET
    public Response getResources(
        @QueryParam("page") @Min(1) @DefaultValue("1") int page,
        @QueryParam("size") @Min(1) @DefaultValue("10") int size,
        @QueryParam("sorting") String sorting
    ) {
        var resources = resourceService.getResources(page, size, sort);
        return Response.ok(resources).build();
    }

    @POST
    public Response createResource(@Valid ResourceCreateRequest request) {
        var resource = resourceService.createResource(request);
        return Response.status(Response.Status.CREATED)
            .entity(resource)
            .build();
    }

    @GET
    @Path("/{id}")
    public Response getResource(@PathParam("id") String id) {
        var resource = resourceService.getResource(id);
        return Response.ok(resource).build();
    }

    @PUT
    @Path("/{id}")
    public Response updateResource(
        @PathParam("id") String id,
        @Valid ResourceUpdateRequest request
    ) {
        var resource = resourceService.updateResource(id, request);
        return Response.ok(resource).build();
    }

    @DELETE
    @Path("/{id}")
    public Response deleteResource(@PathParam("id") String id) {
        resourceService.deleteResource(id);
        return Response.noContent().build();
    }
}
```

## Data Transfer Objects (DTOs)

### DTO Design Principles

1. **Use consistent naming patterns**:
   - `EntityName` for domain models
   - `EntityNameCreateRequest` for creation requests
   - `EntityNameUpdateRequest` for update requests
   - `EntityNameResponse` for responses

2. **Implement proper validation**:

```java
public class ResourceCreateRequest {
    @NotBlank(message = "Name is required")
    @Size(max = 255, message = "Name cannot exceed 255 characters")
    private String name;

    @NotNull(message = "Type is required")
    private ResourceType type;

    @Email(message = "Invalid email format")
    private String email;

    @JsonView(Views.Public.class)
    private String description;

    // Getters and setters
}
```

3. **Use JsonView for serialization control**:

```java
public class Views {
    public interface Public {}
    public interface Internal extends Public {}
    public interface Admin extends Internal {}
}

public class ResourceResponse {
    @JsonView(Views.Public.class)
    private String id;

    @JsonView(Views.Public.class)
    private String name;

    @JsonView(Views.Internal.class)
    private String internalData;

    @JsonView(Views.Admin.class)
    private String adminOnlyData;
}
```

## Validation and Error Handling

### Input Validation

1. **Always use @Valid annotation**:

   ```java
   @POST
   public Response createResource(@Valid ResourceCreateRequest request) {
       // Implementation
   }
   ```

2. **Implement custom validators when needed**:

   ```java
   @Target({ElementType.FIELD})
   @Retention(RetentionPolicy.RUNTIME)
   @Constraint(validatedBy = CustomValidator.class)
   public @interface CustomValidation {
       String message() default "Invalid value";
       Class<?>[] groups() default {};
       Class<? extends Payload>[] payload() default {};
   }
   ```

### Error Response Structure

Use Dropwizard error message:

```java
io.dropwizard.jersey.errors.ErrorMessage
```

Or the Opik custom one:

```java
com.comet.opik.api.error.ErrorMessage
```

## API Documentation

### Swagger Annotations

1. **Document all endpoints**:

   ```java
   @Operation(
       summary = "Create a new resource",
       description = "Creates a new resource with the provided data"
   )
   @ApiResponses({
       @ApiResponse(
           responseCode = "201",
           description = "Resource created successfully",
           content = @Content(schema = @Schema(implementation = ResourceResponse.class))
       ),
       @ApiResponse(
           responseCode = "400",
           description = "Invalid input data"
       )
   })
   @POST
   public Response createResource(@Valid ResourceCreateRequest request) {
       // Implementation
   }
   ```

2. **Document request/response models**:

   ```java
   @Schema(description = "Request to create a new resource")
   public class ResourceCreateRequest {
       @Schema(description = "Resource name", example = "My Resource")
       private String name;
   }
   ```

## Service Layer Integration

### Service Implementation

```java
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ResourceService {
    
    private final @NonNull ResourceDao resourceDao;
    private final @NonNull IdGenerator idGenerator;

    public ResourceResponse createResource(ResourceCreateRequest request) {
        var resource = Resource.builder()
            .id(idGenerator.generate())
            .name(request.getName())
            .type(request.getType())
            .build();
        
        return resourceDao.create(resource);
    }

    public ResourceResponse getResource(String id) {
        return resourceDao.findById(id)
            .orElseThrow(() -> new NotFoundException("Resource not found: '%s'".formatted(id)));
    }
}
```

## Best Practices

### Performance and Scalability

1. **Use pagination for list endpoints**:

   ```java
   @GET
   public Response getResources(
        @QueryParam("page") @Min(1) @DefaultValue("1") int page,
        @QueryParam("size") @Min(1) @DefaultValue("10") int size
   ) {
       // Implementation with pagination
   }
   ```

2. **Implement proper caching headers**:

   ```java
   @GET
   @Path("/{id}")
   public Response getResource(@PathParam("id") String id) {
       var resource = resourceService.getResource(id);
       return Response.ok(resource)
           .cacheControl(CacheControl.maxAge(Duration.ofMinutes(5)))
           .build();
   }
   ```

### Security Considerations

1. **Validate all inputs**:
   - Use `@Valid` annotations
   - Implement custom validators for complex validation
   - Sanitize user inputs

### Testing Guidelines

1. **Test all endpoints**:
   - Happy path scenarios
   - Error conditions
   - Validation failures
   - Authorization checks

2. **Use integration tests**:

   ```java
   @Test
   void shouldCreateResource_whenValidRequest() {
       var request = new ResourceCreateRequest("Test Resource", ResourceType.BASIC);
       
       var response = client.target("/api/v1/resources")
           .request()
           .post(Entity.json(request));
       
       assertThat(response.getStatus()).isEqual(Response.Status.CREATED);
   }
   ```

## Common Patterns

### Search and Filtering

```java
@GET
public Response getResources(
    @QueryParam("filters") String filters,
    @QueryParam("type") ResourceType type,
    @QueryParam("page") @Min(1) @DefaultValue("1") int page,
    @QueryParam("size") @Min(1) @DefaultValue("10") int size
) {
    var filters = ResourceFilters.builder()
        .search(search)
        .type(type)
        .build();
    
    var resources = resourceService.getResources(filters, page, size);
    return Response.ok(resources).build();
}
```

### Batch Operations

```java
@POST
@Path("/batch")
public Response createResources(@Valid List<ResourceCreateRequest> requests) {
    var resources = resourceService.createResources(requests);
    return Response.status(Response.Status.CREATED)
        .entity(resources)
        .build();
}
```

## Key References

- [Dropwizard Documentation](https://www.dropwizard.io/en/latest/)
- [JAX-RS Specification](https://jax-rs.github.io/)
- [Jakarta Validation](https://beanvalidation.org/)
- [OpenAPI Specification](https://swagger.io/specification/)
