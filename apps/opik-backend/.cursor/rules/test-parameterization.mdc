---
globs: **/*Test.java,**/*IT.java
---
# Java Test Parameterization Best Practices

## Parameterized Test Guidelines

### Use Parameterized Tests to Reduce Duplication

**Rule**: When testing multiple values/scenarios of the same behavior, use `@ParameterizedTest` with `@MethodSource` instead of writing separate test methods.

### ❌ BAD: Duplicate Test Methods

```java
@Test
void testSortByNameAsc() {
    // Test logic for name ASC
}

@Test
void testSortByNameDesc() {
    // Same logic for name DESC
}

@Test
void testSortByTypeAsc() {
    // Same logic for type ASC
}

@Test
void testSortByTypeDesc() {
    // Same logic for type DESC
}
```

### ✅ GOOD: Single Parameterized Test

```java
@ParameterizedTest(name = "Sort by {0} {1}")
@MethodSource("sortingTestCases")
@DisplayName("Sort evaluators by various fields with ASC/DESC")
void sortEvaluators(String field, String direction, Comparator<Entity> comparator) {
    // Single test method handles all sorting scenarios
}

static Stream<Arguments> sortingTestCases() {
    return Stream.of(
        Arguments.of("name", "ASC", Comparator.comparing(Entity::getName)),
        Arguments.of("name", "DESC", Comparator.comparing(Entity::getName).reversed()),
        Arguments.of("type", "ASC", Comparator.comparing(e -> e.getType().name())),
        Arguments.of("type", "DESC", Comparator.comparing(e -> e.getType().name()).reversed())
    );
}
```

## Test Coverage Requirements

### Ensure All Factory Fields Are Tested

**Critical**: When testing sorting/filtering functionality, ensure ALL fields from the corresponding factory class are included in parameterized tests at least once.

```java
// Reference: AutomationRuleEvaluatorSortingFactory has fields: 
// id, name, type, enabled, sampling_rate, project_id, project_name, 
// created_at, last_updated_at, created_by, last_updated_by

// ✅ GOOD: All factory fields covered in test parameters
static Stream<Arguments> sortingTestCases() {
    return Stream.of(
        Arguments.of("id", "ASC", Comparator.comparing(Entity::getId)),
        Arguments.of("name", "ASC", Comparator.comparing(Entity::getName)),
        Arguments.of("type", "ASC", Comparator.comparing(e -> e.getType().name())),
        Arguments.of("enabled", "ASC", Comparator.comparing(Entity::isEnabled)),
        Arguments.of("sampling_rate", "ASC", Comparator.comparing(Entity::getSamplingRate)),
        Arguments.of("project_id", "ASC", Comparator.comparing(Entity::getProjectId)),
        Arguments.of("project_name", "ASC", Comparator.comparing(Entity::getProjectName)),
        Arguments.of("created_at", "ASC", Comparator.comparing(Entity::getCreatedAt)),
        Arguments.of("last_updated_at", "ASC", Comparator.comparing(Entity::getLastUpdatedAt)),
        Arguments.of("created_by", "ASC", Comparator.comparing(Entity::getCreatedBy)),
        Arguments.of("last_updated_by", "ASC", Comparator.comparing(Entity::getLastUpdatedBy))
        // Include DESC variants as needed
    );
}
```

## Test Method Parameters

### Use Comparator Instead of Function Extractor

**Pattern**: For sorting tests, use `Comparator<T>` as the parameter type instead of `Function<T, Comparable<?>>`.

```java
// ❌ BAD: Using Function with wildcards (harder to work with)
void sortEvaluators(String field, String direction,
        java.util.function.Function<AutomationRuleEvaluator<?>, Comparable> extractor)

// ✅ GOOD: Using Comparator (cleaner and more flexible)
void sortEvaluators(String field, String direction,
        Comparator<AutomationRuleEvaluator<?>> comparator)
```

### Use Proper Imports

**Always use imports** instead of fully qualified class names in test signatures:

```java
// ❌ BAD: Fully qualified class names
static Stream<org.junit.jupiter.params.provider.Arguments> sortingTestCases() {
    return Stream.of(
        org.junit.jupiter.params.provider.Arguments.of(...)
    );
}

// ✅ GOOD: Proper imports
import org.junit.jupiter.params.provider.Arguments;

static Stream<Arguments> sortingTestCases() {
    return Stream.of(
        Arguments.of(...)
    );
}
```

## Test Data Generation

### Leverage PojoFactory Random Generation

**Rule**: Use `factory.manufacturePojo()` to generate random test data instead of manually setting values, unless specific values are required for the test case.

```java
// ❌ BAD: Manually setting values that don't need to be specific
var builder = factory.manufacturePojo(AutomationRuleEvaluatorLlmAsJudge.class).toBuilder()
    .projectId(projectId);

if (field.equals("name")) {
    builder.name("name-" + (char) ('a' + i) + "-" + RandomStringUtils.randomAlphanumeric(5));
} else if (field.equals("sampling_rate")) {
    builder.samplingRate((float) (i + 1) / 10);
}

// ✅ GOOD: Let factory generate random values, only override when necessary
var evaluator = factory.manufacturePojo(AutomationRuleEvaluatorLlmAsJudge.class).toBuilder()
    .projectId(projectId)
    .build();

// Factory generates sufficiently random values for testing sorting
// If values collide, use secondary sort by id (which is time-based)
```

## Pagination Testing

### Use Single Parameterized Test for Pagination

```java
// ❌ BAD: Three separate pagination test methods
@Test
void paginationPage1() { /* ... */ }

@Test
void paginationPage2() { /* ... */ }

@Test
void paginationLastPage() { /* ... */ }

// ✅ GOOD: One parameterized test
@ParameterizedTest(name = "Fetch page {0} with size {1}")
@MethodSource("paginationTestCases")
void testPagination(int pageNumber, int pageSize, int expectedSize, int totalRecords) {
    // Single test handles all pagination scenarios
}

static Stream<Arguments> paginationTestCases() {
    return Stream.of(
        Arguments.of(1, 10, 10, 25), // First page
        Arguments.of(2, 10, 10, 25), // Middle page
        Arguments.of(3, 10, 5, 25)   // Last page with fewer items
    );
}
```

## Test Organization

### Group Related Tests in Single Nested Class

```java
// ❌ BAD: Multiple nested classes for similar functionality
@Nested
class SortingFunctionality { }

@Nested
class ListFilteringFunctionality { }

@Nested
class PaginationFunctionality { }

@Nested
class ProjectIdFilteringFunctionality { }

// ✅ GOOD: Combine related tests into logical groups
@Nested
@DisplayName("Search, Filter, and Sort Functionality")
class SearchFilterSortFunctionality {
    
    @ParameterizedTest
    void testSorting(...) { }
    
    @ParameterizedTest
    void testFiltering(...) { }
    
    @ParameterizedTest
    void testPagination(...) { }
}
```

## Reference Examples

For well-structured parameterized tests, refer to:
- [AnnotationQueuesResourceTest.java](mdc:apps/opik-backend/src/test/java/com/comet/opik/api/resources/v1/priv/AnnotationQueuesResourceTest.java)
- [AlertResourceTest.java](mdc:apps/opik-backend/src/test/java/com/comet/opik/api/resources/v1/priv/AlertResourceTest.java)

## Related Rules

- [Testing Guidelines](mdc:apps/opik-backend/.cursor/rules/testing.mdc)
- [Code Quality](mdc:apps/opik-backend/.cursor/rules/code_quality.mdc)
