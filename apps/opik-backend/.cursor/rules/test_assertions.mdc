---
description: Tests Assertions
globs: apps/opik-backend/**/*
alwaysApply: false
---
# Backend Test Assertion Patterns

## Testing Sorting Logic

### Test Actual Sorting, Not Self-Fulfilling Prophecy

**Critical Issue**: Tests must verify that the API actually sorts data correctly, not just verify that sorting the same list twice produces the same result.

### ❌ BAD: Self-Fulfilling Test (Does Not Test Sorting)

```java
@Test
void testSorting() {
    // Create test data
    createTestData();
    
    // Fetch from API with sorting
    var page = api.findSorted("name", "ASC");
    
    // ❌ BAD: Extract actual values, then sort them, then compare
    var actualValues = page.content().stream()
        .map(Entity::getName)
        .toList();
    
    var expectedValues = new ArrayList<>(actualValues);
    expectedValues.sort(Comparator.naturalOrder()); // Sorting the actual results!
    
    assertThat(actualValues).isEqualTo(expectedValues);
    // This test will ALWAYS pass, even if API sorting is broken!
}
```

**Why This Is Wrong**: This test extracts actual values from the API response, sorts those same values, and then compares them. This will always pass regardless of whether the API actually sorted correctly.

### ✅ GOOD: Test Against Known Data Order

```java
@Test
void testSorting() {
    // Create test data with KNOWN values in KNOWN order
    var entity1 = createEntity("Alice", 100);
    var entity2 = createEntity("Bob", 200);
    var entity3 = createEntity("Charlie", 300);
    
    // Fetch from API with sorting by name ASC
    var page = api.findSorted("name", "ASC");
    
    // ✅ GOOD: Verify actual API order matches expected order
    assertThat(page.content())
        .extracting(Entity::getName)
        .containsExactly("Alice", "Bob", "Charlie");
    
    // Verify with DESC
    var pageDesc = api.findSorted("name", "DESC");
    assertThat(pageDesc.content())
        .extracting(Entity::getName)
        .containsExactly("Charlie", "Bob", "Alice");
}
```

### ✅ ALTERNATIVE: Use AssertJ Sorting Assertions

```java
@Test
void testSorting() {
    // Create test data
    createRandomTestData(10);
    
    // Fetch with sorting
    var page = api.findSorted("name", "ASC");
    
    // ✅ GOOD: Use AssertJ to verify list is sorted
    assertThat(page.content())
        .extracting(Entity::getName)
        .isSorted(); // This checks actual sorting
    
    // For DESC
    var pageDesc = api.findSorted("name", "DESC");
    assertThat(pageDesc.content())
        .extracting(Entity::getName)
        .isSortedAccordingTo(Comparator.reverseOrder());
}
```

### ✅ BEST: Compare Against Pre-Sorted Data

```java
@ParameterizedTest
@MethodSource("sortingTestCases")
void testSorting(String field, String direction, Comparator<Entity> comparator) {
    // Create test data
    var entities = IntStream.range(0, 5)
        .mapToObj(i -> factory.manufacturePojo(Entity.class))
        .toList();
    
    entities.forEach(e -> api.create(e));
    
    // Sort the ORIGINAL test data using the expected comparator
    var expectedOrder = entities.stream()
        .sorted(direction.equals("ASC") ? comparator : comparator.reversed())
        .map(Entity::getId)
        .toList();
    
    // Fetch from API with sorting
    var page = api.findSorted(field, direction);
    
    // ✅ BEST: Compare API result against independently sorted original data
    var actualOrder = page.content().stream()
        .map(Entity::getId)
        .toList();
    
    assertThat(actualOrder).isEqualTo(expectedOrder);
}
```

## Why The Bad Pattern Fails

The problematic pattern:
```java
var actualValues = getFromApi();
var expectedValues = new ArrayList<>(actualValues);
expectedValues.sort(...);
assertThat(actualValues).isEqualTo(expectedValues);
```

This is a **tautology** - it will always pass because:
1. You're comparing a list against a sorted version of itself
2. Even if the API returned completely random order, this test would pass
3. The test doesn't verify the API did any sorting

**This pattern doesn't test anything meaningful!**

## Proper Sorting Test Structure

### Three Valid Approaches:

1. **Known Values**: Create entities with specific values, verify exact order
2. **Sorting Assertions**: Use AssertJ's `.isSorted()` or `.isSortedAccordingTo()`
3. **Pre-Sorted Comparison**: Sort original data independently, compare with API results

### Complete Example

```java
@Nested
@DisplayName("Sorting Tests")
class SortingTests {
    
    @ParameterizedTest(name = "Sort by {0} {1}")
    @MethodSource("sortingTestCases")
    void testEntitySorting(String field, String direction, 
                          Comparator<Entity> comparator) {
        // Arrange: Create 10 entities with random data
        var originalEntities = IntStream.range(0, 10)
            .mapToObj(i -> factory.manufacturePojo(Entity.class))
            .toList();
        
        // Save to database
        originalEntities.forEach(entity -> repository.save(entity));
        
        // Act: Query with sorting
        var result = service.findAll(field, direction);
        
        // Assert: Verify sorting
        // Method 1: Check if sorted using AssertJ
        var actualValues = result.stream()
            .map(getFieldExtractor(field))
            .toList();
        
        if (direction.equals("ASC")) {
            assertThat(actualValues).isSorted();
        } else {
            assertThat(actualValues).isSortedAccordingTo(Comparator.reverseOrder());
        }
        
        // Method 2: Compare with independently sorted original data
        var expectedOrder = originalEntities.stream()
            .sorted(direction.equals("ASC") ? comparator : comparator.reversed())
            .map(Entity::getId)
            .toList();
        
        var actualOrder = result.stream()
            .map(Entity::getId)
            .toList();
        
        assertThat(actualOrder).isEqualTo(expectedOrder);
    }
    
    static Stream<Arguments> sortingTestCases() {
        return Stream.of(
            Arguments.of("name", "ASC", Comparator.comparing(Entity::getName)),
            Arguments.of("name", "DESC", Comparator.comparing(Entity::getName)),
            Arguments.of("createdAt", "ASC", Comparator.comparing(Entity::getCreatedAt)),
            Arguments.of("createdAt", "DESC", Comparator.comparing(Entity::getCreatedAt))
        );
    }
}
```

## Testing Filtering Logic

Similar principles apply to filtering tests - verify against known data:

```java
@Test
void testFiltering() {
    // Create entities with known values
    var entity1 = createEntity("test-123");
    var entity2 = createEntity("test-456");
    var entity3 = createEntity("other-789");
    
    // Apply filter
    var results = api.findByName("test");
    
    // ✅ GOOD: Verify against known matching entities
    assertThat(results)
        .extracting(Entity::getId)
        .containsExactlyInAnyOrder(entity1.getId(), entity2.getId())
        .doesNotContain(entity3.getId());
}
```

## Related Rules

- [Testing Guidelines](mdc:apps/opik-backend/.cursor/rules/testing.mdc)
