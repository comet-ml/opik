---
description: Architecture guidelines
globs: apps/opik-backend/**/*
alwaysApply: false
---

# Architecture Guidelines

Comprehensive guidelines for designing and implementing scalable, maintainable architecture in the Opik backend.

## High level guidelines

- Applications must be reactive, non-blocking, and horizontally scalable
- Ensure separation of concerns between architectural layers
- Resources → API layer
- Services → Business logic
- Dao → Persistence layer
- Use a modular architecture to enable independent development and testing

## Core Architecture Principles

### 1. **Reactive and Non-Blocking Design**

- Applications must be reactive, non-blocking, and horizontally scalable
- Use non-blocking processing for I/O operations
- Implement proper error handling and recovery mechanisms
- Design for high availability and fault tolerance

### 2. **Separation of Concerns**

- Maintain clear boundaries between architectural layers
- Each layer has a single responsibility
- Minimize coupling between layers
- Use dependency injection for loose coupling

## Layered Architecture

### **Resource Layer (API Layer)**

- **Purpose**: Handle HTTP requests and responses
- **Responsibilities**:
  - Request validation and parsing
  - Response formatting
  - HTTP status code management

```java
@Path("/api/v1/resources")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ResourcesResource {

    private final @NonNull ResourceService resourceService;

    @GET
    public Response getResources(
        @QueryParam("page") @Min(1) @DefaultValue("1") int page,
        @QueryParam("size") @Min(1) @DefaultValue("10") int size,
        @QueryParam("sorting") String sorting
    ) {
        var resources = resourceService.getResources(page, size, sorting);
        return Response.ok(resources).build();
    }

    @POST
    public Response createResource(@Valid ResourceCreateRequest request) {
        var resource = resourceService.createResource(request);
        return Response.status(Response.Status.CREATED)
            .entity(resource)
            .build();
    }
}
```

### **Service Layer (Business Logic)**

- **Purpose**: Implement business rules and orchestrate operations
- **Responsibilities**:
  - Business logic implementation
  - Data transformation
  - Cross-cutting concerns (logging, metrics)

```java
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ResourceService {
    
    private final @NonNull ResourceDao resourceDao;
    private final @NonNull IdGenerator idGenerator;

    public ResourceResponse createResource(ResourceCreateRequest request) {
        var resource = Resource.builder()
            .id(idGenerator.generate())
            .name(request.getName())
            .type(request.getType())
            .build();
        
        return resourceDao.create(resource);
    }

    public ResourceResponse getResource(String id) {
        return resourceDao.findById(id)
            .orElseThrow(() -> new NotFoundException("Resource not found: '%s'".formatted(id)));
    }
}
```

### **DAO Layer (Persistence Layer)**

- **Purpose**: Handle data persistence and retrieval
- **Responsibilities**:
  - Database operations
  - Query optimization
  - Data mapping
  - Connection management

```java
@RegisterRowMapper(ResourceRowMapper.class)
public interface ResourceDao {
    
    @SqlQuery("SELECT * FROM resources WHERE id = :id")
    Optional<Resource> findById(@Bind("id") String id);
    
    @SqlUpdate("INSERT INTO resources (id, name, type, created_at) VALUES (:id, :name, :type, :createdAt)")
    @GetGeneratedKeys
    Resource create(@BindBean Resource resource);
    
    @SqlQuery("SELECT * FROM resources ORDER BY created_at DESC LIMIT :limit OFFSET :offset")
    List<Resource> findAll(@Bind("limit") int limit, @Bind("offset") int offset);
}
```

## Modular Architecture

### **Module Organization**

- Use Guice modules for dependency injection
- Group related functionality in modules
- Keep modules focused and cohesive
- Enable independent development and testing

### **Configuration Management**

- Use Dropwizard configuration classes
- Use type-safe configuration
- Document configuration options
- Use secure configuration practices

```java
public class OpikConfiguration extends Configuration {
    
    @JsonProperty("database")
    private DatabaseConfiguration database;
    
    @JsonProperty("redis")
    private RedisConfiguration redis;
    
    @JsonProperty("jobs")
    private JobsConfiguration jobs;
    
    // Getters and setters
}
```

## Scalability Patterns

### **Horizontal Scaling**

- Design stateless services
- Use external state management (Redis, database)
- Implement proper session management

### **Performance Optimization**

- Implement caching strategies
- Optimize database queries
- Implement pagination for large datasets

```java
// Caching example
@Singleton
public class ResourceCacheService {
    
    private final @NonNull RedissonClient redissonClient;
    
    public ResourceResponse getCachedResource(String id) {
        var cache = redissonClient.getMapCache("resources");
        return cache.get(id, ResourceResponse.class);
    }
    
    public void cacheResource(String id, ResourceResponse resource) {
        var cache = redissonClient.getMapCache("resources");
        cache.put(id, resource, Duration.ofMinutes(30));
    }
}
```

## Error Handling and Resilience

### **Exception Handling**

- Use specific exception types
- Implement proper error responses
- Log errors with context
- Provide meaningful error messages

### **Circuit Breaker Pattern**

- Implement circuit breakers for external services
- Use fallback mechanisms
- Implement retry strategies

## Testing Architecture

### **Unit Testing**

- Test each layer independently
- Use mocks for dependencies
- Test business logic thoroughly
- Maintain high test coverage

```java
@Test
void shouldCreateResource_whenValidRequest() {
    // Given
    var request = new ResourceCreateRequest("Test Resource", ResourceType.BASIC);
    var expectedResource = Resource.builder()
        .id("test-id")
        .name("Test Resource")
        .type(ResourceType.BASIC)
        .build();
    
    when(idGenerator.generate()).thenReturn("test-id");
    when(resourceDao.create(any(Resource.class))).thenReturn(expectedResource);
    
    // When
    var result = resourceService.createResource(request);
    
    // Then
    assertThat(result.getName()).isEqualTo("Test Resource");
    verify(resourceDao).create(any(Resource.class));
}
```

### **Integration Testing**

- Test layer interactions
- Use test containers for databases
- Test complete workflows
- Verify data consistency

## Monitoring and Observability

### **Logging Strategy**

- Use structured logging
- Include correlation IDs
- Log at appropriate levels
- Include relevant context

```java
@Slf4j
public class ResourceService {
    
    public ResourceResponse createResource(ResourceCreateRequest request) {
        log.info("Creating resource with name: {}", request.getName());
        
        try {
            var resource = // ... implementation
            log.info("Successfully created resource with id: {}", resource.getId());
            return resource;
        } catch (Exception exception) {
            log.error("Failed to create resource: {}", request.getName(), exception);
            throw exception;
        }
    }
}
```

### **Metrics and Monitoring**

- Implement health checks
- Use OpenTelemetry for tracing

## Best Practices

### **Code Organization**

- Follow package naming conventions
- Group related classes together
- Use meaningful package names
- Keep packages focused

### **Dependency Management**

- Use dependency injection
- Avoid circular dependencies
- Keep dependencies minimal

## Key References

- [Dropwizard Architecture](https://www.dropwizard.io/en/latest/manual/core.html)
- [JDBI3 Database Access](https://jdbi.org/)
- [OpenTelemetry Observability](https://opentelemetry.io/)
- [Redis Caching](https://redis.io/)
