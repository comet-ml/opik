---
description: Error handling best practices for Opik backend
globs: **/*.java
alwaysApply: false
---

# Error Handling Guidelines

Comprehensive guidelines for implementing proper error handling and exception management in the Opik backend.

## Core Principles

### **Graceful Exception Handling**

- Always handle exceptions gracefully to prevent application crashes
- Provide meaningful error messages to users and developers
- Log errors with appropriate context for debugging
- Use structured error responses for API endpoints
- Use `io.dropwizard.jersey.errors.ErrorMessage` as the primary error response class
- Use `com.comet.opik.api.error.ErrorMessage` for complex error responses with additional details
- Do not create new error message classes

### **Specific Exception Catching**

**Avoid catching generic exceptions:**

```java
// ❌ Bad: Catching generic Exception
try {
    userService.createUser(request);
} catch (Exception e) {
    log.error("Error occurred", e);
    return Response.serverError().build();
}

// ✅ Good: Catching specific exceptions
try {
    var result = externalService.callApi(request);
    return processResult(result);
} catch (HttpClientException exception) {
    log.error("External service call failed", exception);
    throw new InternalServerErrorException("Service temporarily unavailable", exception);
} catch (JsonProcessingException exception) {
    log.error("Failed to parse response", exception);
    throw new BadRequestException("Invalid response format", exception);
} catch (TimeoutException exception) {
    log.warn("Request timed out after '{}'ms", timeoutMs, exception);
    throw new InternalServerErrorException("Request timed out", exception);
}
```

## Exception Hierarchy

### **Business Exceptions**

Use existing Jakarta exceptions for standard HTTP status codes:

```java
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.UnauthorizedException;
import jakarta.ws.rs.ForbiddenException;
import jakarta.ws.rs.ConflictException;

// Validation errors
throw new BadRequestException("User email is required");

// Resource not found
throw new NotFoundException("User not found: '%s'".formatted(userId));

// Business rule violations
throw new ConflictException("User account is suspended");

// Authorization errors
throw new UnauthorizedException("Insufficient permissions");
```

### **Technical Exceptions**

Handle technical exceptions appropriately:

```java
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.InternalServerErrorException;

// Database errors
catch (SQLException exception) {
    log.error("Database operation failed", exception);
    throw new InternalServerErrorException("Failed to persist data", exception);
}

// External service errors
catch (HttpClientException exception) {
    log.error("External service call failed", exception);
    throw new InternalServerErrorException("Service temporarily unavailable", exception);
}

// Configuration errors
catch (ConfigurationException exception) {
    log.error("Configuration error", exception);
    throw new InternalServerErrorException("System configuration error", exception);
}
```

## Service Layer Error Handling

### **Business Logic Exceptions**

```java
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.ConflictException;
import jakarta.ws.rs.InternalServerErrorException;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class UserService {
    
    private final @NonNull UserDao userDao;
    private final @NonNull IdGenerator idGenerator;
    
    public UserResponse createUser(UserCreateRequest request) {
        try {
            // Validate input
            if (request.getName() == null || request.getName().trim().isEmpty()) {
                throw new BadRequestException("User name is required");
            }
            
            // Check for existing user
            if (userDao.findByEmail(request.getEmail()).isPresent()) {
                throw new ConflictException("User with this email already exists");
            }
            
            // Create user
            var user = User.builder()
                .id(idGenerator.generate())
                .name(request.getName())
                .email(request.getEmail())
                .build();
            
            return userDao.create(user);
            
        } catch (BadRequestException | ConflictException exception) {
            // Re-throw business exceptions
            throw exception;
        } catch (Exception exception) {
            log.error("Failed to create user", exception);
            throw new InternalServerErrorException("Failed to create user", exception);
        }
    }
    
    public UserResponse getUser(String id) {
        return userDao.findById(id)
            .orElseThrow(() -> new NotFoundException("User not found: '%s'".formatted(id)));
    }
}
```

### **DAO Layer Error Handling**

```java
import jakarta.ws.rs.InternalServerErrorException;

@RegisterRowMapper(UserRowMapper.class)
public interface UserDao {
    
    @SqlQuery("SELECT * FROM users WHERE id = :id")
    Optional<User> findById(@Bind("id") String id);
    
    @SqlUpdate("INSERT INTO users (id, name, email, created_at) VALUES (:id, :name, :email, :createdAt)")
    @GetGeneratedKeys
    User create(@BindBean User user);
    
            default UserResponse createUser(User user) {
        try {
            return create(user);
        } catch (SQLException exception) {
            log.error("Database error while creating user", exception);
            throw new InternalServerErrorException("Failed to create user in database", exception);
        }
    }
}
```

## Resource Layer Error Handling

### **REST API Error Responses**

Use ExceptionMapper for centralized error handling instead of manual try-catch blocks:

```java
import io.dropwizard.jersey.errors.ErrorMessage;

@Slf4j
public class BadRequestExceptionMapper implements ExceptionMapper<BadRequestException> {

    @Override
    public Response toResponse(BadRequestException exception) {
        log.warn("Bad request exception: {}", exception.getMessage());

        return Response.status(Response.Status.BAD_REQUEST)
                .entity(new ErrorMessage(Response.Status.BAD_REQUEST.getStatusCode(),
                        "Bad request. " + exception.getMessage()))
                .build();
    }
}

@Slf4j
public class NotFoundExceptionMapper implements ExceptionMapper<NotFoundException> {

    @Override
    public Response toResponse(NotFoundException exception) {
        log.warn("Resource not found: {}", exception.getMessage());

        return Response.status(Response.Status.NOT_FOUND)
                .entity(new ErrorMessage(Response.Status.NOT_FOUND.getStatusCode(),
                        "Resource not found. " + exception.getMessage()))
                .build();
    }
}

@Slf4j
public class ConflictExceptionMapper implements ExceptionMapper<ConflictException> {

    @Override
    public Response toResponse(ConflictException exception) {
        log.warn("Conflict exception: {}", exception.getMessage());

        return Response.status(Response.Status.CONFLICT)
                .entity(new ErrorMessage(Response.Status.CONFLICT.getStatusCode(),
                        "Conflict. " + exception.getMessage()))
                .build();
    }
}
```

### **Resource Implementation**

Resources should focus on business logic, not error handling:

```java
@Path("/api/v1/users")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class UsersResource {
    
    private final @NonNull UserService userService;
    
    @POST
    public Response createUser(@Valid UserCreateRequest request) {
        var user = userService.createUser(request);
        return Response.status(Response.Status.CREATED)
            .entity(user)
            .build();
    }
    
    @GET
    @Path("/{id}")
    public Response getUser(@PathParam("id") String id) {
        var user = userService.getUser(id);
        return Response.ok(user).build();
    }
}
```

## Logging Best Practices

### **Structured Error Logging**

**Never log sensitive data such as PII, passwords, credentials, or personal information:**

```java
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.InternalServerErrorException;

@Slf4j
public class UserService {
    
    public UserResponse createUser(UserCreateRequest request) {
        try {
            // Business logic implementation
            var user = userDao.create(buildUser(request));
            log.info("Successfully created user with id: {}", user.getId());
            return user;
            
        } catch (BadRequestException exception) {
            log.warn("Validation failed for user creation", exception);
            throw exception;
        } catch (SQLException exception) {
            log.error("Database error while creating user", exception);
            throw new InternalServerErrorException("Failed to create user", exception);
        }
    }
    
    public UserResponse getUser(String id) {
        try {
            var user = userDao.findById(id)
                .orElseThrow(() -> new NotFoundException("User not found: '%s'".formatted(id)));
            return user;
            
        } catch (NotFoundException exception) {
            log.warn("User not found: '{}'", id, exception);
            throw exception;
        } catch (SQLException exception) {
            log.error("Database error while retrieving user: '{}'", id, exception);
            throw new InternalServerErrorException("Failed to retrieve user", exception);
        }
    }
}
```

### **Sensitive Data Logging Guidelines**

**❌ Never log:**
- Email addresses, phone numbers, names
- Passwords, API keys, tokens
- Credit card numbers, SSNs
- Personal identifiers
- Database credentials
- Configuration secrets

**✅ Safe to log:**
- User IDs, workspace IDs
- Operation names, method names
- Error codes, status codes
- Timestamps, durations
- Non-sensitive metadata

### **Logging Format Conventions**

**Always surround logged values with single quotes:**
```java
// ✅ Good: Values surrounded with quotes
log.info("Successfully created user with id: '{}'", user.getId());
log.warn("User not found: '{}'", id, exception);
log.error("Failed to create user for workspace: '{}'", workspaceId, exception);

// ❌ Bad: Values not surrounded with quotes
log.info("Successfully created user with id: {}", user.getId());
log.warn("User not found: {}", id, exception);
log.error("Failed to create user for workspace: {}", workspaceId, exception);
```

### **Context-Rich Logging**

```java
// Include relevant context in log messages (avoiding sensitive data)
log.error("Failed to create user for workspace: '{}'", 
    request.getWorkspaceId(), exception);

// Use structured logging for complex errors
log.error("Database transaction failed", Map.of(
    "operation", "create_user",
    "user_id", userId,
    "error_code", exception.getErrorCode(),
    "sql_state", exception.getSQLState()
), exception);
```

## Error Response Patterns

### **Standardized Error Messages**

Use Dropwizard's ErrorMessage class as the first option:

```java
import io.dropwizard.jersey.errors.ErrorMessage;

// Usage in responses
return Response.status(Response.Status.BAD_REQUEST)
    .entity(new ErrorMessage(
        Response.Status.BAD_REQUEST.getStatusCode(),
        "Invalid input data"
    ))
    .build();
```

For more complex error responses, use the Opik custom ErrorMessage:

```java
import com.comet.opik.api.error.ErrorMessage;
import java.util.List;

// Usage in responses with additional details
return Response.status(Response.Status.BAD_REQUEST)
    .entity(new ErrorMessage(
        List.of("Email format is invalid", "Name is required"),
        "VALIDATION_ERROR"
    ))
    .build();
```

**Note:** No additional error message classes should be created. Use only these two existing classes.

### **HTTP Status Code Mapping**

Use existing Jakarta exceptions for standard HTTP status codes:

```java
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.UnauthorizedException;
import jakarta.ws.rs.ForbiddenException;
import jakarta.ws.rs.ConflictException;
import jakarta.ws.rs.InternalServerErrorException;

// 400 Bad Request - Validation errors
throw new BadRequestException("Invalid input");

// 401 Unauthorized - Authentication required
throw new UnauthorizedException("Authentication required");

// 403 Forbidden - Insufficient permissions
throw new ForbiddenException("Insufficient permissions");

// 404 Not Found - Resource not found
throw new NotFoundException("Resource not found");

// 409 Conflict - Business rule violations
throw new ConflictException("Resource already exists");

// 500 Internal Server Error - System errors
throw new InternalServerErrorException("Internal system error");
```

**Note:** Use Jakarta exceptions for standard HTTP status codes. Only create custom exceptions when Jakarta doesn't provide an appropriate one.

## Testing Error Scenarios

### **Exception Testing**

```java
@Test
void shouldThrowBadRequestException_whenInvalidEmail() {
    // Given
    var request = new UserCreateRequest("John Doe", "invalid-email");
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(BadRequestException.class)
        .hasMessageContaining("Invalid email format");
}

@Test
void shouldThrowNotFoundException_whenUserDoesNotExist() {
    // Given
    var nonExistentId = "non-existent-id";
    
    // When & Then
    assertThatThrownBy(() -> userService.getUser(nonExistentId))
        .isInstanceOf(NotFoundException.class)
        .hasMessageContaining("User not found");
}
```

## Best Practices Summary

### **Do's:**

- ✅ Catch specific exceptions rather than generic ones
- ✅ Provide meaningful error messages
- ✅ Log errors with appropriate context
- ✅ Use appropriate HTTP status codes
- ✅ Handle exceptions at the appropriate layer
- ✅ Test error scenarios thoroughly

### **Don'ts:**

- ❌ Catch `Exception` or `Throwable` or `RuntimeException` without re-throwing
- ❌ Swallow exceptions silently
- ❌ Expose sensitive information in error messages
- ❌ Use generic error messages
- ❌ Log exceptions without context
- ❌ Return null instead of throwing exceptions

## Key References

- [Dropwizard Error Handling](https://www.dropwizard.io/en/latest/manual/core.html#error-handling)
- [SLF4J Logging](http://www.slf4j.org/)
- [Jakarta Validation](https://beanvalidation.org/)
