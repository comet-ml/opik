---
description: MySQL transaction usage guidelines for opik-backend
globs:
alwaysApply: true
---
# MySQL Transaction Guidelines

Comprehensive guidelines for using MySQL transactions in the Opik backend with JDBI3 and TransactionTemplate.

## Core Principles

### **Always Use Transactions**

- **Always use transactions** for MySQL reads/writes
- **Use TransactionTemplate** for consistent transaction management
- **Handle exceptions gracefully** within transaction blocks
- **Keep transaction blocks focused** on database operations

### **Transaction Types**

```java
import static com.comet.opik.infrastructure.db.TransactionTemplateAsync.READ_ONLY;
import static com.comet.opik.infrastructure.db.TransactionTemplateAsync.WRITE;

// For read operations
transactionTemplate.inTransaction(READ_ONLY, handle -> {
    // Read-only database operations
});

// For write operations
transactionTemplate.inTransaction(WRITE, handle -> {
    // Write database operations
});
```

## Transaction Implementation

### **Service Layer Pattern**

```java
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class UserService {
    
    private final @NonNull UserDao userDao;
    private final @NonNull IdGenerator idGenerator;
    private final @NonNull TransactionTemplate transactionTemplate;

    public UserResponse createUser(UserCreateRequest request) {
        return transactionTemplate.inTransaction(WRITE, handle -> {
            var repository = handle.attach(UserDao.class);
            
            var user = User.builder()
                .id(idGenerator.generate())
                .name(request.getName())
                .email(request.getEmail())
                .createdAt(Instant.now())
                .build();
            
            return repository.create(user);
        });
    }

    public UserResponse getUser(String id) {
        return transactionTemplate.inTransaction(READ_ONLY, handle -> {
            var repository = handle.attach(UserDao.class);
            return repository.findById(id)
                .orElseThrow(() -> new NotFoundException("User not found: '%s'".formatted(id)));
        });
    }

    public List<UserResponse> getUsers(int page, int size) {
        return transactionTemplate.inTransaction(READ_ONLY, handle -> {
            var repository = handle.attach(UserDao.class);
            return repository.findAll(page, size);
        });
    }
}
```

### **DAO Layer Pattern**

```java
@RegisterRowMapper(UserRowMapper.class)
public interface UserDao {
    
    @SqlQuery("SELECT * FROM users WHERE id = :id")
    Optional<User> findById(@Bind("id") String id);
    
    @SqlUpdate("INSERT INTO users (id, name, email, created_at) VALUES (:id, :name, :email, :createdAt)")
    @GetGeneratedKeys
    User create(@BindBean User user);
    
    @SqlQuery("SELECT * FROM users ORDER BY created_at DESC LIMIT :limit OFFSET :offset")
    List<User> findAll(@Bind("limit") int limit, @Bind("offset") int offset);
}
```

## Error Handling

### **Exception Handling in Transactions**

```java
public UserResponse createUser(UserCreateRequest request) {
    try {
        return transactionTemplate.inTransaction(WRITE, handle -> {
            var repository = handle.attach(UserDao.class);
            
            // Check for existing user
            if (repository.findByEmail(request.getEmail()).isPresent()) {
                throw new ConflictException("User with this email already exists");
            }
            
            var user = User.builder()
                .id(idGenerator.generate())
                .name(request.getName())
                .email(request.getEmail())
                .createdAt(Instant.now())
                .build();
            
            return repository.create(user);
        });
    } catch (SQLException exception) {
        log.error("Database error while creating user", exception);
        throw new InternalServerErrorException("Failed to create user", exception);
    }
}
```

### **Graceful Exception Handling**

```java
public UserResponse updateUser(String id, UserUpdateRequest request) {
    try {
        return transactionTemplate.inTransaction(WRITE, handle -> {
            var repository = handle.attach(UserDao.class);
            
            var existingUser = repository.findById(id)
                .orElseThrow(() -> new NotFoundException("User not found: '%s'".formatted(id)));
            
            var updatedUser = existingUser.toBuilder()
                .name(request.getName())
                .email(request.getEmail())
                .updatedAt(Instant.now())
                .build();
            
            return repository.update(updatedUser);
        });
    } catch (SQLException exception) {
        log.error("Database error while updating user: '{}'", id, exception);
        throw new InternalServerErrorException("Failed to update user", exception);
    }
}
```

## Best Practices

### **Transaction Block Guidelines**

```java
// ✅ Good: Focused transaction block
public UserResponse createUser(UserCreateRequest request) {
    return transactionTemplate.inTransaction(WRITE, handle -> {
        var repository = handle.attach(UserDao.class);
        
        // Only database operations inside transaction
        var user = buildUser(request);
        return repository.create(user);
    });
}

// ❌ Bad: Unrelated logic in transaction block
public UserResponse createUser(UserCreateRequest request) {
    return transactionTemplate.inTransaction(WRITE, handle -> {
        var repository = handle.attach(UserDao.class);
        
        // Don't do this - unrelated logic
        sendEmailNotification(request.getEmail());
        updateCache();
        
        var user = buildUser(request);
        return repository.create(user);
    });
}
```

### **DAO Interface Guidelines**

```java
// ✅ Good: Use interfaces for DAOs
@RegisterRowMapper(UserRowMapper.class)
public interface UserDao {
    
    @SqlQuery("SELECT * FROM users WHERE id = :id")
    Optional<User> findById(@Bind("id") String id);
    
    @SqlUpdate("INSERT INTO users (id, name, email, created_at) VALUES (:id, :name, :email, :createdAt)")
    @GetGeneratedKeys
    User create(@BindBean User user);
}

// ✅ Good: Minimal logic can be inline
@RegisterRowMapper(UserRowMapper.class)
public interface UserDao {
    
    default UserResponse createUser(User user) {
        try {
            return create(user);
        } catch (SQLException exception) {
            log.error("Database error while creating user", exception);
            throw new InternalServerErrorException("Failed to create user in database", exception);
        }
    }
}
```

## Performance Considerations

### **Read-Only Transactions**

```java
// Use READ_ONLY for queries that don't modify data
public List<UserResponse> searchUsers(String searchTerm) {
    return transactionTemplate.inTransaction(READ_ONLY, handle -> {
        var repository = handle.attach(UserDao.class);
        return repository.searchByName(searchTerm);
    });
}
```

### **Write Transactions**

```java
// Use WRITE for operations that modify data
public void deleteUser(String id) {
    transactionTemplate.inTransaction(WRITE, handle -> {
        var repository = handle.attach(UserDao.class);
        repository.deleteById(id);
        return null;
    });
}
```

## Common Patterns

### **Batch Operations**

```java
public List<UserResponse> createUsers(List<UserCreateRequest> requests) {
    return transactionTemplate.inTransaction(WRITE, handle -> {
        var repository = handle.attach(UserDao.class);
        var users = new ArrayList<UserResponse>();
        
        for (var request : requests) {
            var user = User.builder()
                .id(idGenerator.generate())
                .name(request.getName())
                .email(request.getEmail())
                .createdAt(Instant.now())
                .build();
            
            users.add(repository.create(user));
        }
        
        return users;
    });
}
```

### **Complex Queries**

```java
public List<UserResponse> getUsersWithFilters(UserFilters filters) {
    return transactionTemplate.inTransaction(READ_ONLY, handle -> {
        var repository = handle.attach(UserDao.class);
        return repository.findWithFilters(filters);
    });
}
```

## Testing Guidelines

### **Transaction Testing**

```java
@Test
void shouldCreateUser_whenValidRequest() {
    // Given
    var request = new UserCreateRequest("John Doe", "john@example.com");
    
    // When
    var result = userService.createUser(request);
    
    // Then
    assertThat(result).isNotNull();
    assertThat(result.getName()).isEqualTo("John Doe");
}
```

### **Exception Testing**

```java
@Test
void shouldThrowException_whenDatabaseError() {
    // Given
    var request = new UserCreateRequest("John Doe", "john@example.com");
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(InternalServerErrorException.class);
}
```

## Key References

- [JDBI3 Documentation](https://jdbi.org/)
- [MySQL Transaction Best Practices](https://dev.mysql.com/doc/refman/8.0/en/commit.html)
- [Dropwizard Database Access](https://www.dropwizard.io/en/latest/manual/jdbi3.html)
- [Transaction Management](https://www.baeldung.com/spring-transactional-propagation-isolation)
