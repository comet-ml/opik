---
description: Code Quality guidelines
globs: apps/opik-backend/**/*
alwaysApply: false
---

# Code Quality Guidelines

Comprehensive guidelines for maintaining high code quality in the Opik backend.

## Code Style and Conventions

### **Style Conventions**

- Code must follow style conventions and be well-documented
- use design patterns where appropriate
- Avoid code duplication; use utility classes or methods
- Ensure code is modular and reusable
- Use consistent indentation (4 spaces)
- Use meaningful variable and method names
- Keep methods short and focused on a single task
- Use comments to explain complex logic or decisions
- Use consistent naming conventions for classes, methods, and variables
- Avoid hardcoding values; use constants or configuration files
- changes must pass spotless checks
- prefer using Map.of(), List.of(), Set.of() for creating immutable collections
- for lists, always use getFirst() or getLast() instead of get(0) or get(size() - 1)

```java
// Good example - Clear naming and structure
public class UserService {
    
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final Duration TIMEOUT_DURATION = Duration.ofSeconds(30);
    
    private final @NonNull UserDao userDao;
    private final @NonNull IdGenerator idGenerator;
    
    public UserResponse createUser(UserCreateRequest request) {
        validateUserRequest(request);
        var user = buildUser(request);
        return persistUser(user);
    }
    
    private void validateUserRequest(UserCreateRequest request) {
        // Validation logic
    }
}

// Bad example - Poor naming and structure
public class UserSvc {
    private UserDao dao;
    private IdGenerator gen;
    
    public UserResponse crtUsr(UserCreateRequest req) {
        // Mixed logic without separation
    }
}
```

### **Documentation Standards**

- Use Javadoc for public methods and classes
- Include parameter descriptions and return values
- Document exceptions that may be thrown
- Use comments to explain complex logic or decisions

```java
/**
 * Creates a new user with the provided information.
 * 
 * @param request the user creation request containing user details
 * @return the created user response
 * @throws ValidationException if the request contains invalid data
 * @throws BusinessException if user creation fails
 */
public UserResponse createUser(UserCreateRequest request) {
    // Implementation
}
```

## Design Patterns and Architecture

### **Use Design Patterns Appropriately**

- Apply design patterns where they add value
- Don't over-engineer simple solutions
- Common patterns: Builder, Factory, Strategy, Observer

### **Modular and Reusable Code**

- Ensure code is modular and reusable
- Extract common functionality into utility classes
- Keep classes focused on single responsibilities

```java
// Utility class for common operations
public final class ValidationUtils {
    
    private ValidationUtils() {
        // Utility class - prevent instantiation
    }
    
    public static boolean isValidEmail(String email) {
        return email != null && email.contains("@");
    }
    
    public static boolean isValidId(String id) {
        return id != null && !id.trim().isEmpty();
    }
}
```

## Code Organization

### **Method Design**

- Keep methods short and focused on a single task
- Use meaningful method names that describe their purpose
- Limit method parameters (use objects for multiple parameters)
- Return early to reduce nesting

```java
// Good example - Short, focused method
public UserResponse createUser(UserCreateRequest request) {
    validateRequest(request);
    var user = buildUser(request);
    return saveUser(user);
}

private void validateRequest(UserCreateRequest request) {
    if (request.getName() == null || request.getName().trim().isEmpty()) {
        throw new ValidationException("Name is required");
    }
}

// Bad example - Long, complex method
public UserResponse createUser(UserCreateRequest request) {
    // 50+ lines of mixed validation, building, and saving logic
}
```

### **Variable and Method Naming**

- Use descriptive names that explain purpose
- Follow Java naming conventions
- Avoid abbreviations and acronyms
- Use consistent naming patterns

```java
// Good naming
public class UserService {
    private final @NonNull UserDao userDao;
    private final @NonNull IdGenerator idGenerator;
    
    public UserResponse createUser(@NonNull UserCreateRequest request) {
        var newUser = buildUser(request);
        return userDao.save(newUser);
    }
}

// Bad naming
public class UserSvc {
    private final UserDao dao;
    private final IdGenerator gen;
    
    public UserResponse crtUsr(UserCreateRequest req) {
        var u = buildUser(req);
        return dao.save(u);
    }
}
```

## Collections and Data Structures

### **Immutable Collections**

- Prefer using `Map.of()`, `List.of()`, `Set.of()` for creating immutable collections
- Use immutable collections when possible
- Avoid modifying collections after creation

```java
// Good - Immutable collections
private static final Set<String> VALID_STATUSES = Set.of("ACTIVE", "INACTIVE", "PENDING");
private static final Map<String, String> CONFIG = Map.of(
    "timeout", "30",
    "retries", "3"
);

// Bad - Mutable collections
private static final List<String> STATUSES = Arrays.asList("ACTIVE", "INACTIVE");
```

### **List Access Patterns**

- For lists, always use `getFirst()` or `getLast()` instead of `get(0)` or `get(size() - 1)`
- Use appropriate list methods for clarity
- Handle empty lists gracefully

```java
// Good - Using getFirst() and getLast()
public String getFirstUserName(List<User> users) {
    if (users.isEmpty()) {
        throw new NotFoundException("No users found");
    }
    return users.getFirst().getName();
}

public String getLastUserName(List<User> users) {
    if (users.isEmpty()) {
        throw new NotFoundException("No users found");
    }
    return users.getLast().getName();
}

// Bad - Using get(0) and get(size() - 1)
public String getFirstUserName(List<User> users) {
    return users.get(0).getName(); // May throw IndexOutOfBoundsException
}
```

## Constants and Configuration

### **Avoid Hardcoding Values**

- Use constants for magic numbers and strings
- Use configuration files for environment-specific values
- Define constants at appropriate scope (class, package, or application level)

```java
// Good - Using constants
public class UserService {
    private static final int MAX_NAME_LENGTH = 255;
    private static final Duration SESSION_TIMEOUT = Duration.ofHours(24);
    private static final String DEFAULT_ROLE = "USER";
    
    public void createUser(UserCreateRequest request) {
        if (request.getName().length() > MAX_NAME_LENGTH) {
            throw new ValidationException("Name too long");
        }
    }
}

// Bad - Hardcoded values
public void createUser(UserCreateRequest request) {
    if (request.getName().length() > 255) { // Magic number
        throw new ValidationException("Name too long");
    }
}
```

### **String Constants and Templates**

**Rule**: When you have repeated string prefixes or patterns, define them as constants with string formatting templates.

```java
// ❌ BAD: Hardcoded Repeated String Patterns
private static final Map<AutomationRuleEvaluatorField, String> FIELD_MAP = new EnumMap<>(
    ImmutableMap.<AutomationRuleEvaluatorField, String>builder()
        .put(AutomationRuleEvaluatorField.ID, "rule." + ID_DB)
        .put(AutomationRuleEvaluatorField.NAME, "rule." + NAME_DB)
        .put(AutomationRuleEvaluatorField.TYPE, "evaluator." + TYPE_DB)
        .put(AutomationRuleEvaluatorField.ENABLED, "evaluator." + ENABLED_DB)
        .put(AutomationRuleEvaluatorField.PROJECT_ID, "evaluator." + PROJECT_ID_DB)
        .build());

// ✅ GOOD: String Template Constants
// Define templates at the top of the class
private static final String RULE_PREFIX = "rule.%s";
private static final String EVALUATOR_PREFIX = "evaluator.%s";

private static final Map<AutomationRuleEvaluatorField, String> FIELD_MAP = new EnumMap<>(
    ImmutableMap.<AutomationRuleEvaluatorField, String>builder()
        .put(AutomationRuleEvaluatorField.ID, RULE_PREFIX.formatted(ID_DB))
        .put(AutomationRuleEvaluatorField.NAME, RULE_PREFIX.formatted(NAME_DB))
        .put(AutomationRuleEvaluatorField.TYPE, EVALUATOR_PREFIX.formatted(TYPE_DB))
        .put(AutomationRuleEvaluatorField.ENABLED, EVALUATOR_PREFIX.formatted(ENABLED_DB))
        .put(AutomationRuleEvaluatorField.PROJECT_ID, EVALUATOR_PREFIX.formatted(PROJECT_ID_DB))
        .build());
```

**Benefits**:
- Single source of truth for prefixes
- Easier to refactor if prefix changes
- More maintainable and readable
- Less error-prone when adding new mappings

### **Constants Organization**

Group related constants by category with clear comments:

```java
public class FilterQueryBuilder {
    
    // Database column names - base fields
    private static final String ID_DB = "id";
    private static final String NAME_DB = "name";
    private static final String TYPE_DB = "type";
    
    // Database column names - timestamps
    private static final String CREATED_AT_DB = "created_at";
    private static final String LAST_UPDATED_AT_DB = "last_updated_at";
    
    // Database column names - audit fields
    private static final String CREATED_BY_DB = "created_by";
    private static final String LAST_UPDATED_BY_DB = "last_updated_by";
    
    // Table prefixes
    private static final String RULE_PREFIX = "rule.%s";
    private static final String EVALUATOR_PREFIX = "evaluator.%s";
    
    // Sensitive fields (DO NOT expose in API)
    // private static final String WEBHOOK_SECRET_TOKEN_DB = "webhook_secret_token"; // REMOVED
}
```

### **Configuration Management**

- Use Dropwizard configuration classes
- Use type-safe configuration

```java
public class DatabaseConfiguration {
    @JsonProperty("url")
    private String url;
    
    @JsonProperty("username")
    private String username;
    
    @JsonProperty("password")
    private String password;
    
    @JsonProperty("maxConnections")
    @Min(1)
    @Max(100)
    private int maxConnections = 10;
    
    // Getters and setters
}
```

## Template Engine Usage

### **StringTemplate4 (ST4) Factory Pattern**

**Rule**: Always use `TemplateUtils.newST()` to create StringTemplate instances. Never use `new ST(template)` directly.

**Problem**: Using `new ST(template)` directly causes templates to be cached in the default STGroup singleton, which prevents garbage collection and leads to unbounded memory growth in high-throughput scenarios.

**Solution**: Use the factory method that creates ephemeral ST instances with dedicated STGroups.

```java
// ✅ GOOD: Use TemplateUtils.newST() factory method
import com.comet.opik.utils.template.TemplateUtils;

public class SpanDAO {
    private static final String QUERY = """
        SELECT * FROM spans 
        WHERE project_id = :project_id
        <if(trace_id)> AND trace_id = :trace_id <endif>
        ORDER BY start_time DESC
        """;
    
    public List<Span> findSpans(UUID projectId, UUID traceId) {
        var template = TemplateUtils.newST(QUERY);
        template.add("project_id", projectId);
        Optional.ofNullable(traceId)
            .ifPresent(id -> template.add("trace_id", id));
        
        String sql = template.render();
        // Execute query with sql
    }
}

// ❌ BAD: Direct ST construction causes memory leaks
import org.stringtemplate.v4.ST;

public class SpanDAO {
    public List<Span> findSpans(UUID projectId, UUID traceId) {
        // This caches the template in default STGroup and causes memory leaks!
        var template = new ST(QUERY);
        template.add("project_id", projectId);
        // ... rest of code
    }
}
```

## Error Handling and Validation

### **Exception Handling**

- Use specific exception types
- Provide meaningful error messages
- Log errors with appropriate context
- Handle exceptions at appropriate levels

```java
// Good - Specific exception handling
public UserResponse getUser(String id) {
    try {
        return userDao.findById(id)
            .orElseThrow(() -> new NotFoundException("User not found: '%s'".formatted(id)));
    } catch (DatabaseException exception) {
        log.error("Database error while fetching user: {}", id, e);
        throw new BusinessException("Failed to retrieve user", exception);
    }
}

// Bad - Generic exception handling
public UserResponse getUser(String id) {
    try {
        return userDao.findById(id).orElse(null);
    } catch (Exception e) {
        log.error("Error: {}", e.getMessage());
        return null;
    }
}
```

## Code Duplication

### **Avoid Code Duplication**

- Extract common functionality into utility methods
- Use inheritance and composition appropriately
- Create reusable components
- Refactor duplicated code into shared methods

```java
// Good - Extracted common validation
public class ValidationUtils {
    
    public static void validateRequired(String value, String fieldName) {
        if (value == null || value.trim().isEmpty()) {
            throw new ValidationException(fieldName + " is required");
        }
    }
    
    public static void validateMaxLength(String value, int maxLength, String fieldName) {
        if (value != null && value.length() > maxLength) {
            throw new ValidationException(fieldName + " cannot exceed " + maxLength + " characters");
        }
    }
}

// Usage in multiple services
public class UserService {
    public void createUser(UserCreateRequest request) {
        ValidationUtils.validateRequired(request.getName(), "Name");
        ValidationUtils.validateMaxLength(request.getName(), 255, "Name");
        // ... rest of implementation
    }
}
```

## Testing and Quality Assurance

### **Code Quality Checks**

- All changes must pass Spotless checks

### **Testing Best Practices**

- Write unit tests for all business logic
- Use meaningful test names
- Test both success and failure scenarios
- Mock external dependencies

```java
@Test
void shouldCreateUser_whenValidRequest() {
    // Given
    var request = new UserCreateRequest("John Doe", "john@example.com");
    var expectedId = "user-123";
    
    when(idGenerator.generate()).thenReturn(expectedId);
    when(userDao.save(any(User.class))).thenReturn(expectedUser);
    
    // When
    var result = userService.createUser(request);
    
    // Then
    assertThat(result.getId()).isEqualTo(expectedId);
    assertThat(result.getName()).isEqualTo("John Doe");
    verify(userDao).save(any(User.class));
}
```

## Performance Considerations

### **Efficient Code Patterns**

- Use appropriate data structures
- Avoid unnecessary object creation
- Use lazy loading when appropriate
- Optimize database queries

```java
// Good - Efficient collection operations
public List<String> getActiveUserNames(List<User> users) {
    return users.stream()
        .filter(User::isActive)
        .map(User::getName)
        .toList();
}
```

## Key References

- [Java Code Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html)
- [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)
- [Spotless Code Formatter](https://github.com/diffplug/spotless)
- [JUnit 5 Testing](https://junit.org/junit5/)
- [AssertJ Assertions](https://assertj.github.io/doc/)
