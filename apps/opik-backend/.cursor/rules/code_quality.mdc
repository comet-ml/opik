---
description: Code Quality guidelines
globs:
alwaysApply: true
---

# Code Quality Guidelines

Comprehensive guidelines for maintaining high code quality in the Opik backend.

## Code Style and Conventions

### **Style Conventions**

- Code must follow style conventions and be well-documented
- use design patterns where appropriate
- Avoid code duplication; use utility classes or methods
- Ensure code is modular and reusable
- Use consistent indentation (4 spaces)
- Use meaningful variable and method names
- Keep methods short and focused on a single task
- Use comments to explain complex logic or decisions
- Use consistent naming conventions for classes, methods, and variables
- Avoid hardcoding values; use constants or configuration files
- changes must pass spotless checks
- prefer using Map.of(), List.of(), Set.of() for creating immutable collections
- for lists, always use getFirst() or getLast() instead of get(0) or get(size() - 1)

```java
// Good example - Clear naming and structure
public class UserService {
    
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final Duration TIMEOUT_DURATION = Duration.ofSeconds(30);
    
    private final @NonNull UserDao userDao;
    private final @NonNull IdGenerator idGenerator;
    
    public UserResponse createUser(UserCreateRequest request) {
        validateUserRequest(request);
        var user = buildUser(request);
        return persistUser(user);
    }
    
    private void validateUserRequest(UserCreateRequest request) {
        // Validation logic
    }
}

// Bad example - Poor naming and structure
public class UserSvc {
    private UserDao dao;
    private IdGenerator gen;
    
    public UserResponse crtUsr(UserCreateRequest req) {
        // Mixed logic without separation
    }
}
```

### **Documentation Standards**

- Use Javadoc for public methods and classes
- Include parameter descriptions and return values
- Document exceptions that may be thrown
- Use comments to explain complex logic or decisions

```java
/**
 * Creates a new user with the provided information.
 * 
 * @param request the user creation request containing user details
 * @return the created user response
 * @throws ValidationException if the request contains invalid data
 * @throws BusinessException if user creation fails
 */
public UserResponse createUser(UserCreateRequest request) {
    // Implementation
}
```

## Design Patterns and Architecture

### **Use Design Patterns Appropriately**

- Apply design patterns where they add value
- Don't over-engineer simple solutions
- Common patterns: Builder, Factory, Strategy, Observer

### **Modular and Reusable Code**

- Ensure code is modular and reusable
- Extract common functionality into utility classes
- Keep classes focused on single responsibilities

```java
// Utility class for common operations
public final class ValidationUtils {
    
    private ValidationUtils() {
        // Utility class - prevent instantiation
    }
    
    public static boolean isValidEmail(String email) {
        return email != null && email.contains("@");
    }
    
    public static boolean isValidId(String id) {
        return id != null && !id.trim().isEmpty();
    }
}
```

## Code Organization

### **Method Design**

- Keep methods short and focused on a single task
- Use meaningful method names that describe their purpose
- Limit method parameters (use objects for multiple parameters)
- Return early to reduce nesting

```java
// Good example - Short, focused method
public UserResponse createUser(UserCreateRequest request) {
    validateRequest(request);
    var user = buildUser(request);
    return saveUser(user);
}

private void validateRequest(UserCreateRequest request) {
    if (request.getName() == null || request.getName().trim().isEmpty()) {
        throw new ValidationException("Name is required");
    }
}

// Bad example - Long, complex method
public UserResponse createUser(UserCreateRequest request) {
    // 50+ lines of mixed validation, building, and saving logic
}
```

### **Variable and Method Naming**

- Use descriptive names that explain purpose
- Follow Java naming conventions
- Avoid abbreviations and acronyms
- Use consistent naming patterns

```java
// Good naming
public class UserService {
    private final @NonNull UserDao userDao;
    private final @NonNull IdGenerator idGenerator;
    
    public UserResponse createUser(@NonNull UserCreateRequest request) {
        var newUser = buildUser(request);
        return userDao.save(newUser);
    }
}

// Bad naming
public class UserSvc {
    private final UserDao dao;
    private final IdGenerator gen;
    
    public UserResponse crtUsr(UserCreateRequest req) {
        var u = buildUser(req);
        return dao.save(u);
    }
}
```

## Collections and Data Structures

### **Immutable Collections**

- Prefer using `Map.of()`, `List.of()`, `Set.of()` for creating immutable collections
- Use immutable collections when possible
- Avoid modifying collections after creation

```java
// Good - Immutable collections
private static final Set<String> VALID_STATUSES = Set.of("ACTIVE", "INACTIVE", "PENDING");
private static final Map<String, String> CONFIG = Map.of(
    "timeout", "30",
    "retries", "3"
);

// Bad - Mutable collections
private static final List<String> STATUSES = Arrays.asList("ACTIVE", "INACTIVE");
```

### **List Access Patterns**

- For lists, always use `getFirst()` or `getLast()` instead of `get(0)` or `get(size() - 1)`
- Use appropriate list methods for clarity
- Handle empty lists gracefully

```java
// Good - Using getFirst() and getLast()
public String getFirstUserName(List<User> users) {
    if (users.isEmpty()) {
        throw new NotFoundException("No users found");
    }
    return users.getFirst().getName();
}

public String getLastUserName(List<User> users) {
    if (users.isEmpty()) {
        throw new NotFoundException("No users found");
    }
    return users.getLast().getName();
}

// Bad - Using get(0) and get(size() - 1)
public String getFirstUserName(List<User> users) {
    return users.get(0).getName(); // May throw IndexOutOfBoundsException
}
```

## Constants and Configuration

### **Avoid Hardcoding Values**

- Use constants for magic numbers and strings
- Use configuration files for environment-specific values
- Define constants at appropriate scope (class, package, or application level)

```java
// Good - Using constants
public class UserService {
    private static final int MAX_NAME_LENGTH = 255;
    private static final Duration SESSION_TIMEOUT = Duration.ofHours(24);
    private static final String DEFAULT_ROLE = "USER";
    
    public void createUser(UserCreateRequest request) {
        if (request.getName().length() > MAX_NAME_LENGTH) {
            throw new ValidationException("Name too long");
        }
    }
}

// Bad - Hardcoded values
public void createUser(UserCreateRequest request) {
    if (request.getName().length() > 255) { // Magic number
        throw new ValidationException("Name too long");
    }
}
```

### **Configuration Management**

- Use Dropwizard configuration classes
- Use type-safe configuration

```java
public class DatabaseConfiguration {
    @JsonProperty("url")
    private String url;
    
    @JsonProperty("username")
    private String username;
    
    @JsonProperty("password")
    private String password;
    
    @JsonProperty("maxConnections")
    @Min(1)
    @Max(100)
    private int maxConnections = 10;
    
    // Getters and setters
}
```

## Error Handling and Validation

### **Exception Handling**

- Use specific exception types
- Provide meaningful error messages
- Log errors with appropriate context
- Handle exceptions at appropriate levels

```java
// Good - Specific exception handling
public UserResponse getUser(String id) {
    try {
        return userDao.findById(id)
            .orElseThrow(() -> new NotFoundException("User not found: '%s'".formatted(id)));
    } catch (DatabaseException exception) {
        log.error("Database error while fetching user: {}", id, e);
        throw new BusinessException("Failed to retrieve user", exception);
    }
}

// Bad - Generic exception handling
public UserResponse getUser(String id) {
    try {
        return userDao.findById(id).orElse(null);
    } catch (Exception e) {
        log.error("Error: {}", e.getMessage());
        return null;
    }
}
```

## Code Duplication

### **Avoid Code Duplication**

- Extract common functionality into utility methods
- Use inheritance and composition appropriately
- Create reusable components
- Refactor duplicated code into shared methods

```java
// Good - Extracted common validation
public class ValidationUtils {
    
    public static void validateRequired(String value, String fieldName) {
        if (value == null || value.trim().isEmpty()) {
            throw new ValidationException(fieldName + " is required");
        }
    }
    
    public static void validateMaxLength(String value, int maxLength, String fieldName) {
        if (value != null && value.length() > maxLength) {
            throw new ValidationException(fieldName + " cannot exceed " + maxLength + " characters");
        }
    }
}

// Usage in multiple services
public class UserService {
    public void createUser(UserCreateRequest request) {
        ValidationUtils.validateRequired(request.getName(), "Name");
        ValidationUtils.validateMaxLength(request.getName(), 255, "Name");
        // ... rest of implementation
    }
}
```

## Testing and Quality Assurance

### **Code Quality Checks**

- All changes must pass Spotless checks

### **Testing Best Practices**

- Write unit tests for all business logic
- Use meaningful test names
- Test both success and failure scenarios
- Mock external dependencies

```java
@Test
void shouldCreateUser_whenValidRequest() {
    // Given
    var request = new UserCreateRequest("John Doe", "john@example.com");
    var expectedId = "user-123";
    
    when(idGenerator.generate()).thenReturn(expectedId);
    when(userDao.save(any(User.class))).thenReturn(expectedUser);
    
    // When
    var result = userService.createUser(request);
    
    // Then
    assertThat(result.getId()).isEqualTo(expectedId);
    assertThat(result.getName()).isEqualTo("John Doe");
    verify(userDao).save(any(User.class));
}
```

## Performance Considerations

### **Efficient Code Patterns**

- Use appropriate data structures
- Avoid unnecessary object creation
- Use lazy loading when appropriate
- Optimize database queries

```java
// Good - Efficient collection operations
public List<String> getActiveUserNames(List<User> users) {
    return users.stream()
        .filter(User::isActive)
        .map(User::getName)
        .toList();
}
```

## Key References

- [Java Code Conventions](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html)
- [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)
- [Spotless Code Formatter](https://github.com/diffplug/spotless)
- [JUnit 5 Testing](https://junit.org/junit5/)
- [AssertJ Assertions](https://assertj.github.io/doc/)
