---
description: Testing
globs: apps/opik-backend/**/*
alwaysApply: false
---
# Testing Guidelines

Comprehensive guidelines for implementing and maintaining high-quality tests in the Opik backend.

## Core Testing Principles

### **Test Coverage Requirements**

- **Ensure strong unit test coverage** for all business logic
- **Changes should by default be covered with tests**
- **Always check first if a test already covers your changes** before creating a new test
- **Use mocks/stubs where appropriate** to isolate units under test
- **Test both success and failure scenarios** thoroughly

### **Testing Framework Stack**

- **JUnit 5** for unit tests
- **AssertJ** for fluent assertions
- **PODAM** for generating test data (with custom `PodamFactoryUtils`)
- **Testcontainers** for integration tests
- **WireMock** for external service mocking

## Test Organization

### **Test Structure**

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();
    
    @Test
    void createUser() {
        // Given
        var request = podamFactory.manufacturePojo(UserCreateRequest.class)
            .toBuilder()
            .name("John Doe")
            .email("john@example.com")
            .build();
        
        var expectedId = "user-123";
        var expectedUser = podamFactory.manufacturePojo(User.class)
            .toBuilder()
            .id(expectedId)
            .name("John Doe")
            .email("john@example.com")
            .build();
        
        when(idGenerator.generate()).thenReturn(expectedId);
        when(userDao.create(any(User.class))).thenReturn(expectedUser);
        
        // When
        var actualUser = userService.createUser(request);
        
        // Then
        assertThat(actualUser).isEqualTo(expectedUser);
        verify(userDao).create(expectedUser);
    }
}
```

### **Test Naming Conventions**

```java
// ✅ Good: Happy path - same name as method being tested
@Test
void createUser() { }

// ✅ Good: Other happy paths - methodNameWhenSomethingDoSomething
@Test
void createUserWhenValidRequestReturnsUser() { }

@Test
void createUserWhenUserExistsReturnsConflict() { }

// ✅ Good: Error paths - methodNameWhenSomethingThrowsSomething
@Test
void createUserWhenInvalidEmailThrowsBadRequestException() { }

@Test
void createUserWhenDatabaseErrorThrowsInternalServerErrorException() { }

// ❌ Bad: Vague test names
@Test
void testCreateUser() { }

@Test
void testException() { }

// ❌ Bad: Using underscores instead of camelCase
@Test
void should_create_user_when_valid_request() { }
```

## Test Data Generation

### **PODAM Configuration**

The Opik backend uses a custom PODAM factory with specific type manufacturers and strategies:

```java
import com.comet.opik.podam.PodamFactoryUtils;

// Create PODAM factory with custom configuration
var podamFactory = PodamFactoryUtils.newPodamFactory();
```

**Available Utility Methods:**
- `PodamFactoryUtils.newPodamFactory()` - Creates factory with custom type manufacturers
- `PodamFactoryUtils.manufacturePojoList()` - Generate List of test objects
- `PodamFactoryUtils.manufacturePojoSet()` - Generate Set of test objects  
- `PodamFactoryUtils.manufacturePojoMap()` - Generate Map of test objects

### **Using PODAM for Test Data**

```java
import com.comet.opik.podam.PodamFactoryUtils;

// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isNotNull();
    // Note: For simple field checks, use object equality when possible
    assertThat(actualUser.getName()).isEqualTo("John Doe");
}

// Using utility methods for collections
@Test
void createUsers() {
    // Given
    var requests = PodamFactoryUtils.manufacturePojoList(podamFactory, UserCreateRequest.class);
    
    // When
    var actualUsers = userService.createUsers(requests);
    
    // Then
    assertThat(actualUsers).hasSize(requests.size());
}
```

### **Leverage Random Generation**

**Rule**: Use `factory.manufacturePojo()` to generate random test data instead of manually setting values, unless specific values are required for the test case.

```java
// ❌ BAD: Manually setting values that don't need to be specific
var builder = factory.manufacturePojo(AutomationRuleEvaluatorLlmAsJudge.class).toBuilder()
    .projectId(projectId);

if (field.equals("name")) {
    builder.name("name-" + (char) ('a' + i) + "-" + RandomStringUtils.randomAlphanumeric(5));
} else if (field.equals("sampling_rate")) {
    builder.samplingRate((float) (i + 1) / 10);
}

// ✅ GOOD: Let factory generate random values, only override when necessary
var evaluator = factory.manufacturePojo(AutomationRuleEvaluatorLlmAsJudge.class).toBuilder()
    .projectId(projectId)
    .build();

// Factory generates sufficiently random values for testing sorting
// If values collide, use secondary sort by id (which is time-based)
```

## Assertion Best Practices

### **Object Equality vs Field-by-Field Assertions**

**Prefer object equality when you have the expected object:**

```java
// ✅ Good: Use object equality when you have the expected object
var expectedUser = podamFactory.manufacturePojo(User.class)
    .toBuilder()
    .id("user-123")
    .name("John Doe")
    .email("john@example.com")
    .build();

when(userDao.create(any(User.class))).thenReturn(expectedUser);

var actualUser = userService.createUser(request);

// Then
assertThat(actualUser).isEqualTo(expectedUser);
verify(userDao).create(expectedUser);
```

**Use field-by-field assertions when you only need to verify specific properties:**

```java
// ✅ Good: Use field assertions for specific property checks
assertThat(result).isNotNull();
assertThat(result.getName()).isEqualTo("John Doe");
assertThat(result.getId()).isNotBlank();
```

### **Using AssertJ for Fluent Assertions**

```java
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser)
        .isNotNull()
        .satisfies(user -> {
            // For complex objects, use object equality when possible
            assertThat(user.getName()).isEqualTo("John Doe");
            assertThat(user.getEmail()).isEqualTo("john@example.com");
            assertThat(user.getId()).isNotBlank();
        });
}

@Test
void createUserWhenInvalidInputThrowsBadRequestException() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("") // Override for invalid case
        .email("invalid-email")
        .build();
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(BadRequestException.class)
        .hasMessageContaining("Name is required");
}
```

## Parameterized Testing

### **Use Parameterized Tests to Reduce Duplication**

**Rule**: When testing multiple values/scenarios of the same behavior, use `@ParameterizedTest` with `@MethodSource` instead of writing separate test methods.

```java
// ❌ BAD: Duplicate Test Methods
@Test
void testSortByNameAsc() {
    // Test logic for name ASC
}

@Test
void testSortByNameDesc() {
    // Same logic for name DESC
}

@Test
void testSortByTypeAsc() {
    // Same logic for type ASC
}

@Test
void testSortByTypeDesc() {
    // Same logic for type DESC
}

// ✅ GOOD: Single Parameterized Test
@ParameterizedTest(name = "Sort by {0} {1}")
@MethodSource("sortingTestCases")
@DisplayName("Sort evaluators by various fields with ASC/DESC")
void sortEvaluators(String field, String direction, Comparator<Entity> comparator) {
    // Single test method handles all sorting scenarios
}

static Stream<Arguments> sortingTestCases() {
    return Stream.of(
        Arguments.of("name", "ASC", Comparator.comparing(Entity::getName)),
        Arguments.of("name", "DESC", Comparator.comparing(Entity::getName).reversed()),
        Arguments.of("type", "ASC", Comparator.comparing(e -> e.getType().name())),
        Arguments.of("type", "DESC", Comparator.comparing(e -> e.getType().name()).reversed())
    );
}
```

### **Basic Parameterized Tests**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@ParameterizedTest
@ValueSource(strings = {"", " ", "   "})
void createUserWhenNameIsEmptyThrowsBadRequestException(String name) {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name(name)
        .email("john@example.com")
        .build();
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(BadRequestException.class)
        .hasMessageContaining("Name is required");
}

static Stream<Arguments> createUserWhenEmailFormatIsValidated() {
    return Stream.of(
        Arguments.of("john@example.com", true),
        Arguments.of("invalid-email", false),
        Arguments.of("test@domain", false),
        Arguments.of("user@test.co.uk", true)
    );
}

@ParameterizedTest
@MethodSource
void createUserWhenEmailFormatIsValidated(String email, boolean expectedValid) {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email(email)
        .build();
    
    // When & Then
    if (expectedValid) {
        assertThatNoException().isThrownBy(() -> userService.createUser(request));
    } else {
        assertThatThrownBy(() -> userService.createUser(request))
            .isInstanceOf(BadRequestException.class)
            .hasMessageContaining("Invalid email format");
    }
}
```

### **Test Coverage Requirements**

**Critical**: When testing sorting/filtering functionality, ensure ALL fields from the corresponding factory class are included in parameterized tests at least once.

```java
// Reference: AutomationRuleEvaluatorSortingFactory has fields: 
// id, name, type, enabled, sampling_rate, project_id, project_name, 
// created_at, last_updated_at, created_by, last_updated_by

// ✅ GOOD: All factory fields covered in test parameters
static Stream<Arguments> sortingTestCases() {
    return Stream.of(
        Arguments.of("id", "ASC", Comparator.comparing(Entity::getId)),
        Arguments.of("name", "ASC", Comparator.comparing(Entity::getName)),
        Arguments.of("type", "ASC", Comparator.comparing(e -> e.getType().name())),
        Arguments.of("enabled", "ASC", Comparator.comparing(Entity::isEnabled)),
        Arguments.of("sampling_rate", "ASC", Comparator.comparing(Entity::getSamplingRate)),
        Arguments.of("project_id", "ASC", Comparator.comparing(Entity::getProjectId)),
        Arguments.of("project_name", "ASC", Comparator.comparing(Entity::getProjectName)),
        Arguments.of("created_at", "ASC", Comparator.comparing(Entity::getCreatedAt)),
        Arguments.of("last_updated_at", "ASC", Comparator.comparing(Entity::getLastUpdatedAt)),
        Arguments.of("created_by", "ASC", Comparator.comparing(Entity::getCreatedBy)),
        Arguments.of("last_updated_by", "ASC", Comparator.comparing(Entity::getLastUpdatedBy))
        // Include DESC variants as needed
    );
}
```

### **Test Data Generation in Parameterized Tests**

For test data generation in parameterized tests, follow the [PODAM guidelines](#podam-configuration) above. Let the factory generate random values and only override when necessary for the specific test scenario.

### **Test Method Parameters**

**Pattern**: For sorting tests, use `Comparator<T>` as the parameter type instead of `Function<T, Comparable<?>>`.

```java
// ❌ BAD: Using Function with wildcards (harder to work with)
void sortEvaluators(String field, String direction,
        java.util.function.Function<AutomationRuleEvaluator<?, ?>, Comparable> extractor)

// ✅ GOOD: Using Comparator (cleaner and more flexible)
void sortEvaluators(String field, String direction,
        Comparator<AutomationRuleEvaluator<?, ?>> comparator)
```

### **Pagination Testing**

Use single parameterized test for pagination scenarios:

```java
// ❌ BAD: Three separate pagination test methods
@Test
void paginationPage1() { /* ... */ }

@Test
void paginationPage2() { /* ... */ }

@Test
void paginationLastPage() { /* ... */ }

// ✅ GOOD: One parameterized test
@ParameterizedTest(name = "Fetch page {0} with size {1}")
@MethodSource("paginationTestCases")
void testPagination(int pageNumber, int pageSize, int expectedSize, int totalRecords) {
    // Single test handles all pagination scenarios
}

static Stream<Arguments> paginationTestCases() {
    return Stream.of(
        Arguments.of(1, 10, 10, 25), // First page
        Arguments.of(2, 10, 10, 25), // Middle page
        Arguments.of(3, 10, 5, 25)   // Last page with fewer items
    );
}
```

### **Test Organization for Parameterized Tests**

Group related tests in single nested class:

```java
// ❌ BAD: Multiple nested classes for similar functionality
@Nested
class SortingFunctionality { }

@Nested
class ListFilteringFunctionality { }

@Nested
class PaginationFunctionality { }

@Nested
class ProjectIdFilteringFunctionality { }

// ✅ GOOD: Combine related tests into logical groups
@Nested
@DisplayName("Search, Filter, and Sort Functionality")
class SearchFilterSortFunctionality {
    
    @ParameterizedTest
    void testSorting(...) { }
    
    @ParameterizedTest
    void testFiltering(...) { }
    
    @ParameterizedTest
    void testPagination(...) { }
}
```

### **Reference Examples**

For well-structured parameterized tests, refer to:
- [AnnotationQueuesResourceTest.java](mdc:apps/opik-backend/src/test/java/com/comet/opik/api/resources/v1/priv/AnnotationQueuesResourceTest.java)
- [AlertResourceTest.java](mdc:apps/opik-backend/src/test/java/com/comet/opik/api/resources/v1/priv/AlertResourceTest.java)

## Mocking and Stubbing

### **Mocking Dependencies**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    var expectedId = "user-123";
    var expectedUser = podamFactory.manufacturePojo(User.class)
        .toBuilder()
        .id(expectedId)
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    when(idGenerator.generate()).thenReturn(expectedId);
    when(userDao.create(any(User.class))).thenReturn(expectedUser);
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isEqualTo(expectedUser);
    verify(userDao).create(expectedUser);
}
```

### **Stubbing External Services**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUserWhenExternalServiceErrorThrowsInternalServerErrorException() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    when(externalService.validateEmail(anyString()))
        .thenThrow(new HttpClientException("Service unavailable"));
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(InternalServerErrorException.class)
        .hasMessageContaining("External service unavailable");
}
```

## Integration Testing

### **Database Integration Tests**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isNotNull();
    
    // Verify in database
    var savedUser = userDao.findById(actualUser.getId());
    assertThat(savedUser).isPresent();
    // For database verification, use object equality when possible
    assertThat(savedUser.get().getName()).isEqualTo("John Doe");
}
```

### **Using Testcontainers**

```java
class UserIntegrationTest {
    
    private final MySQLContainer<?> MYSQL = MySQLContainerUtils.newMySQLContainer();
    
    private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

    @Test
    void createUser() {
        // Given
        var request = podamFactory.manufacturePojo(UserCreateRequest.class)
            .toBuilder()
            .name("John Doe")
            .email("john@example.com")
            .build();
        
        // When
        var actualUser = userService.createUser(request);
        
        // Then
        assertThat(actualUser).isNotNull();
        // Additional database assertions
    }
}
```

## Performance Testing

### **Test Execution Optimization**

```java
// ✅ Good: Run specific tests
mvn test -Dtest="UserServiceTest#shouldCreateUser_whenValidRequest"

// ✅ Good: Run test class
mvn test -Dtest="UserServiceTest"

// ❌ Bad: Run entire test suite for development
mvn test
```

## Error Scenario Testing

### **Exception Testing**

```java
@Test
void getUserWhenUserDoesNotExistThrowsNotFoundException() {
    // Given
    var nonExistentId = "non-existent-id";
    when(userDao.findById(nonExistentId)).thenReturn(Optional.empty());
    
    // When & Then
    assertThatThrownBy(() -> userService.getUser(nonExistentId))
        .isInstanceOf(NotFoundException.class)
        .hasMessageContaining("User not found");
}

// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUserWhenUserAlreadyExistsThrowsConflictException() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("existing@example.com")
        .build();
    
    var existingUser = podamFactory.manufacturePojo(User.class)
        .toBuilder()
        .email("existing@example.com")
        .build();
    
    when(userDao.findByEmail("existing@example.com"))
        .thenReturn(Optional.of(existingUser));
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(ConflictException.class)
        .hasMessageContaining("User with this email already exists");
}
```

## Test Maintenance

### **Test Review Checklist**

- [ ] Test covers the main functionality
- [ ] Test covers error scenarios
- [ ] Test uses descriptive names
- [ ] Test is isolated and independent
- [ ] Test uses appropriate mocks/stubs
- [ ] Test includes proper assertions
- [ ] Test follows naming conventions
- [ ] Test is not redundant with existing tests

### **Refactoring Tests**

```java
// ✅ Good: Extract common setup
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@BeforeEach
void setUp() {
    when(idGenerator.generate()).thenReturn("test-id");
}

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isNotNull();
}
```

## Best Practices Summary

### **Do's:**

- ✅ Write tests for all business logic
- ✅ Use descriptive test names
- ✅ Use PODAM for test data generation
- ✅ Use AssertJ for fluent assertions
- ✅ Use @ParameterizedTest for multiple scenarios
- ✅ Mock external dependencies
- ✅ Test both success and failure scenarios
- ✅ Keep tests isolated and independent
- ✅ Run specific tests during development

### **Don'ts:**

- ❌ Skip writing tests for new features
- ❌ Use vague test names
- ❌ Test implementation details
- ❌ Create brittle tests that depend on external state
- ❌ Run entire test suite for every change
- ❌ Ignore existing test coverage
- ❌ Write tests that are not maintainable

## Key References

- [JUnit 5 Documentation](https://junit.org/junit5/)
- [AssertJ Documentation](https://assertj.github.io/doc/)
- [PODAM Documentation](https://github.com/mtedone/podam)
- [Testcontainers Documentation](https://www.testcontainers.org/)
- [Mockito Documentation](https://site.mockito.org/)
