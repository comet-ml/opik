---
description: Testing
globs:
alwaysApply: true
---
# Testing Guidelines

Comprehensive guidelines for implementing and maintaining high-quality tests in the Opik backend.

## Core Testing Principles

### **Test Coverage Requirements**

- **Ensure strong unit test coverage** for all business logic
- **Changes should by default be covered with tests**
- **Always check first if a test already covers your changes** before creating a new test
- **Use mocks/stubs where appropriate** to isolate units under test
- **Test both success and failure scenarios** thoroughly

### **Testing Framework Stack**

- **JUnit 5** for unit tests
- **AssertJ** for fluent assertions
- **PODAM** for generating test data (with custom `PodamFactoryUtils`)
- **Testcontainers** for integration tests
- **WireMock** for external service mocking

## Test Organization

### **Test Structure**

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();
    
    @Test
    void createUser() {
        // Given
        var request = podamFactory.manufacturePojo(UserCreateRequest.class)
            .toBuilder()
            .name("John Doe")
            .email("john@example.com")
            .build();
        
        var expectedId = "user-123";
        var expectedUser = podamFactory.manufacturePojo(User.class)
            .toBuilder()
            .id(expectedId)
            .name("John Doe")
            .email("john@example.com")
            .build();
        
        when(idGenerator.generate()).thenReturn(expectedId);
        when(userDao.create(any(User.class))).thenReturn(expectedUser);
        
        // When
        var actualUser = userService.createUser(request);
        
        // Then
        assertThat(actualUser).isEqualTo(expectedUser);
        verify(userDao).create(expectedUser);
    }
}
```

### **Test Naming Conventions**

```java
// ✅ Good: Happy path - same name as method being tested
@Test
void createUser() { }

// ✅ Good: Other happy paths - methodNameWhenSomethingDoSomething
@Test
void createUserWhenValidRequestReturnsUser() { }

@Test
void createUserWhenUserExistsReturnsConflict() { }

// ✅ Good: Error paths - methodNameWhenSomethingThrowsSomething
@Test
void createUserWhenInvalidEmailThrowsBadRequestException() { }

@Test
void createUserWhenDatabaseErrorThrowsInternalServerErrorException() { }

// ❌ Bad: Vague test names
@Test
void testCreateUser() { }

@Test
void testException() { }

// ❌ Bad: Using underscores instead of camelCase
@Test
void should_create_user_when_valid_request() { }
```

## Test Data Generation

### **PODAM Configuration**

The Opik backend uses a custom PODAM factory with specific type manufacturers and strategies:

```java
import com.comet.opik.podam.PodamFactoryUtils;

// Create PODAM factory with custom configuration
var podamFactory = PodamFactoryUtils.newPodamFactory();
```

**Available Utility Methods:**
- `PodamFactoryUtils.newPodamFactory()` - Creates factory with custom type manufacturers
- `PodamFactoryUtils.manufacturePojoList()` - Generate List of test objects
- `PodamFactoryUtils.manufacturePojoSet()` - Generate Set of test objects  
- `PodamFactoryUtils.manufacturePojoMap()` - Generate Map of test objects

### **Using PODAM for Test Data**

```java
import com.comet.opik.podam.PodamFactoryUtils;

// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isNotNull();
    // Note: For simple field checks, use object equality when possible
    assertThat(actualUser.getName()).isEqualTo("John Doe");
}

// Using utility methods for collections
@Test
void createUsers() {
    // Given
    var requests = PodamFactoryUtils.manufacturePojoList(podamFactory, UserCreateRequest.class);
    
    // When
    var actualUsers = userService.createUsers(requests);
    
    // Then
    assertThat(actualUsers).hasSize(requests.size());
}
```

## Assertion Best Practices

### **Object Equality vs Field-by-Field Assertions**

**Prefer object equality when you have the expected object:**

```java
// ✅ Good: Use object equality when you have the expected object
var expectedUser = podamFactory.manufacturePojo(User.class)
    .toBuilder()
    .id("user-123")
    .name("John Doe")
    .email("john@example.com")
    .build();

when(userDao.create(any(User.class))).thenReturn(expectedUser);

var actualUser = userService.createUser(request);

// Then
assertThat(actualUser).isEqualTo(expectedUser);
verify(userDao).create(expectedUser);
```

**Use field-by-field assertions when you only need to verify specific properties:**

```java
// ✅ Good: Use field assertions for specific property checks
assertThat(result).isNotNull();
assertThat(result.getName()).isEqualTo("John Doe");
assertThat(result.getId()).isNotBlank();
```

### **Using AssertJ for Fluent Assertions**

```java
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser)
        .isNotNull()
        .satisfies(user -> {
            // For complex objects, use object equality when possible
            assertThat(user.getName()).isEqualTo("John Doe");
            assertThat(user.getEmail()).isEqualTo("john@example.com");
            assertThat(user.getId()).isNotBlank();
        });
}

@Test
void createUserWhenInvalidInputThrowsBadRequestException() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("") // Override for invalid case
        .email("invalid-email")
        .build();
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(BadRequestException.class)
        .hasMessageContaining("Name is required");
}
```

## Parameterized Testing

### **Using @ParameterizedTest**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@ParameterizedTest
@ValueSource(strings = {"", " ", "   "})
void createUserWhenNameIsEmptyThrowsBadRequestException(String name) {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name(name)
        .email("john@example.com")
        .build();
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(BadRequestException.class)
        .hasMessageContaining("Name is required");
}

static Stream<Arguments> createUserWhenEmailFormatIsValidated() {
    return Stream.of(
        Arguments.of("john@example.com", true),
        Arguments.of("invalid-email", false),
        Arguments.of("test@domain", false),
        Arguments.of("user@test.co.uk", true)
    );
}

@ParameterizedTest
@MethodSource
void createUserWhenEmailFormatIsValidated(String email, boolean expectedValid) {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email(email)
        .build();
    
    // When & Then
    if (expectedValid) {
        assertThatNoException().isThrownBy(() -> userService.createUser(request));
    } else {
        assertThatThrownBy(() -> userService.createUser(request))
            .isInstanceOf(BadRequestException.class)
            .hasMessageContaining("Invalid email format");
    }
}
```

## Mocking and Stubbing

### **Mocking Dependencies**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    var expectedId = "user-123";
    var expectedUser = podamFactory.manufacturePojo(User.class)
        .toBuilder()
        .id(expectedId)
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    when(idGenerator.generate()).thenReturn(expectedId);
    when(userDao.create(any(User.class))).thenReturn(expectedUser);
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isEqualTo(expectedUser);
    verify(userDao).create(expectedUser);
}
```

### **Stubbing External Services**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUserWhenExternalServiceErrorThrowsInternalServerErrorException() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    when(externalService.validateEmail(anyString()))
        .thenThrow(new HttpClientException("Service unavailable"));
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(InternalServerErrorException.class)
        .hasMessageContaining("External service unavailable");
}
```

## Integration Testing

### **Database Integration Tests**

```java
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isNotNull();
    
    // Verify in database
    var savedUser = userDao.findById(actualUser.getId());
    assertThat(savedUser).isPresent();
    // For database verification, use object equality when possible
    assertThat(savedUser.get().getName()).isEqualTo("John Doe");
}
```

### **Using Testcontainers**

```java
class UserIntegrationTest {
    
    private final MySQLContainer<?> MYSQL = MySQLContainerUtils.newMySQLContainer();
    
    private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

    @Test
    void createUser() {
        // Given
        var request = podamFactory.manufacturePojo(UserCreateRequest.class)
            .toBuilder()
            .name("John Doe")
            .email("john@example.com")
            .build();
        
        // When
        var actualUser = userService.createUser(request);
        
        // Then
        assertThat(actualUser).isNotNull();
        // Additional database assertions
    }
}
```

## Performance Testing

### **Test Execution Optimization**

```java
// ✅ Good: Run specific tests
mvn test -Dtest=UserServiceTest#shouldCreateUser_whenValidRequest

// ✅ Good: Run test class
mvn test -Dtest=UserServiceTest

// ❌ Bad: Run entire test suite for development
mvn test
```

## Error Scenario Testing

### **Exception Testing**

```java
@Test
void getUserWhenUserDoesNotExistThrowsNotFoundException() {
    // Given
    var nonExistentId = "non-existent-id";
    when(userDao.findById(nonExistentId)).thenReturn(Optional.empty());
    
    // When & Then
    assertThatThrownBy(() -> userService.getUser(nonExistentId))
        .isInstanceOf(NotFoundException.class)
        .hasMessageContaining("User not found");
}

// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@Test
void createUserWhenUserAlreadyExistsThrowsConflictException() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("existing@example.com")
        .build();
    
    var existingUser = podamFactory.manufacturePojo(User.class)
        .toBuilder()
        .email("existing@example.com")
        .build();
    
    when(userDao.findByEmail("existing@example.com"))
        .thenReturn(Optional.of(existingUser));
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(ConflictException.class)
        .hasMessageContaining("User with this email already exists");
}
```

## Test Maintenance

### **Test Review Checklist**

- [ ] Test covers the main functionality
- [ ] Test covers error scenarios
- [ ] Test uses descriptive names
- [ ] Test is isolated and independent
- [ ] Test uses appropriate mocks/stubs
- [ ] Test includes proper assertions
- [ ] Test follows naming conventions
- [ ] Test is not redundant with existing tests

### **Refactoring Tests**

```java
// ✅ Good: Extract common setup
// In test class
private final PodamFactory podamFactory = PodamFactoryUtils.newPodamFactory();

@BeforeEach
void setUp() {
    when(idGenerator.generate()).thenReturn("test-id");
}

@Test
void createUser() {
    // Given
    var request = podamFactory.manufacturePojo(UserCreateRequest.class)
        .toBuilder()
        .name("John Doe")
        .email("john@example.com")
        .build();
    
    // When
    var actualUser = userService.createUser(request);
    
    // Then
    assertThat(actualUser).isNotNull();
}
```

## Best Practices Summary

### **Do's:**

- ✅ Write tests for all business logic
- ✅ Use descriptive test names
- ✅ Use PODAM for test data generation
- ✅ Use AssertJ for fluent assertions
- ✅ Use @ParameterizedTest for multiple scenarios
- ✅ Mock external dependencies
- ✅ Test both success and failure scenarios
- ✅ Keep tests isolated and independent
- ✅ Run specific tests during development

### **Don'ts:**

- ❌ Skip writing tests for new features
- ❌ Use vague test names
- ❌ Test implementation details
- ❌ Create brittle tests that depend on external state
- ❌ Run entire test suite for every change
- ❌ Ignore existing test coverage
- ❌ Write tests that are not maintainable

## Key References

- [JUnit 5 Documentation](https://junit.org/junit5/)
- [AssertJ Documentation](https://assertj.github.io/doc/)
- [PODAM Documentation](https://github.com/mtedone/podam)
- [Testcontainers Documentation](https://www.testcontainers.org/)
- [Mockito Documentation](https://site.mockito.org/)
