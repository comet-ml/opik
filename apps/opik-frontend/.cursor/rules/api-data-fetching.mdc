---
description: Frontend API and data fetching patterns using React Query
globs: apps/opik-frontend/**/*
alwaysApply: false
---

# API & Data Fetching Patterns

## React Query Hook Structure

### Query Hook Template

```typescript
// File: src/api/entity/useEntityList.ts
import { useQuery } from "@tanstack/react-query";
import api, { ENTITY_KEY, ENTITY_REST_ENDPOINT } from "@/api/api";

type UseEntityListParams = {
  workspaceName: string;
  search?: string;
  sorting?: Sorting;
  page: number;
  size: number;
};

const getEntityList = async (
  { signal }: QueryFunctionContext,
  params: UseEntityListParams,
) => {
  const { data } = await api.get(ENTITY_REST_ENDPOINT, {
    signal,
    params: {
      workspace_name: params.workspaceName,
      ...processSorting(params.sorting),
      ...(params.search && { name: params.search }),
      size: params.size,
      page: params.page,
    },
  });
  return data;
};

export default function useEntityList(
  params: UseEntityListParams,
  options?: QueryConfig<UseEntityListResponse>,
) {
  return useQuery({
    queryKey: [ENTITY_KEY, params],
    queryFn: (context) => getEntityList(context, params),
    ...options,
  });
}
```

### Query Key Patterns

- Use descriptive keys: `[ENTITIES_KEY, params]`
- Include all parameters that affect the query
- Use constants for query keys defined in `api.ts`

### Data Processing

```typescript
// Simple fallbacks (no useMemo needed)
const entities = data?.content ?? [];
const totalItems = data?.total ?? 0;

// Complex transformations (use useMemo)
const processedEntities = useMemo(() => {
  return (
    data?.content
      ?.filter((entity) => entity.status === "active")
      ?.map((entity) => ({
        ...entity,
        displayName: formatEntityName(entity),
      })) ?? []
  );
}, [data?.content]);
```

## Mutation Patterns

### Basic Mutation

```typescript
const mutation = useMutation({
  mutationFn: deleteEntity,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: [ENTITIES_KEY] });
    toast({ description: "Entity deleted successfully" });
  },
  onError: (error) => {
    toast({ description: "Failed to delete entity", variant: "destructive" });
  },
});
```

### Optimistic Updates

```typescript
const updateMutation = useMutation({
  mutationFn: updateEntity,
  onMutate: async (newEntity) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: [ENTITIES_KEY] });

    // Snapshot previous value
    const previousEntities = queryClient.getQueryData([ENTITIES_KEY]);

    // Optimistically update
    queryClient.setQueryData([ENTITIES_KEY], (old) => ({
      ...old,
      content:
        old?.content?.map((entity) =>
          entity.id === newEntity.id ? { ...entity, ...newEntity } : entity,
        ) ?? [],
    }));

    return { previousEntities };
  },
  onError: (err, newEntity, context) => {
    // Rollback on error
    queryClient.setQueryData([ENTITIES_KEY], context?.previousEntities);
  },
  onSettled: () => {
    // Always refetch after error or success
    queryClient.invalidateQueries({ queryKey: [ENTITIES_KEY] });
  },
});
```

## Loading and Error States

### Loading Patterns

```typescript
// Query loading
if (isLoading) return <Loader />;
if (error) return <div>Error: {error.message}</div>;

// Component loading
{isLoading && <Skeleton className="h-4 w-full" />}

// Button loading
<Button disabled={isLoading}>
  {isLoading && <Spinner className="mr-2" />}
  Submit
</Button>
```

### Toast Notifications

```typescript
import { useToast } from "@/components/ui/use-toast";

const { toast } = useToast();

// Success toast
toast({ description: "Operation completed successfully" });

// Error toast
toast({
  description: "Operation failed",
  variant: "destructive",
});
```

## API Response Handling

### Error Boundaries

```typescript
// Use React Query's built-in error handling
const { data, error, isLoading, isError } = useQuery({
  queryKey: ['entity', id],
  queryFn: fetchEntity,
  retry: (failureCount, error) => {
    // Don't retry on 4xx errors
    if (error.status >= 400 && error.status < 500) {
      return false;
    }
    return failureCount < 3;
  },
});

if (isError) {
  return <ErrorComponent message={error.message} />;
}
```

### Pagination Handling

```typescript
const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
  useInfiniteQuery({
    queryKey: ["entities"],
    queryFn: ({ pageParam = 1 }) => fetchEntities({ page: pageParam }),
    getNextPageParam: (lastPage) => {
      return lastPage.hasMore ? lastPage.page + 1 : undefined;
    },
  });
```
