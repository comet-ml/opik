---
description: Frontend code quality standards, TypeScript patterns, and naming conventions
globs: "**/*"
alwaysApply: false
---

# Frontend Code Quality Standards

## TypeScript Patterns

### Component Type Definitions
```typescript
// ✅ Always define explicit prop interfaces
interface ComponentProps {
  title: string;
  description?: string;
  onAction: (id: string) => void;
  children: React.ReactNode;
}

// ✅ Always use React.FunctionComponent<Props>
const Component: React.FunctionComponent<ComponentProps> = ({
  title,
  description,
  onAction,
  children,
}) => {
  // Component implementation
};

// ❌ Avoid: Implicit or any types
const Component = ({ title, description, onAction, children }: any) => {
  // Bad: no type safety
};
```

### API Response Types
```typescript
// ✅ Use strict type checking for API responses
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

interface UserData {
  id: string;
  name: string;
  email: string;
  createdAt: string;
}

// ✅ Type API calls properly
const fetchUser = async (id: string): Promise<ApiResponse<UserData>> => {
  const response = await api.get(`/users/${id}`);
  return response.data;
};
```

### Union Types vs Enums
```typescript
// ✅ Prefer type unions for simple cases
type ButtonVariant = 'default' | 'outline' | 'ghost' | 'destructive';
type Size = 'sm' | 'md' | 'lg';

// ✅ Use enums for complex cases with methods
enum UserRole {
  ADMIN = 'admin',
  USER = 'user',
  GUEST = 'guest',
}

// ✅ Const assertions for readonly arrays
const VALID_STATUSES = ['pending', 'approved', 'rejected'] as const;
type Status = typeof VALID_STATUSES[number];
```

### Complex Function Types
```typescript
// ✅ Always provide return types for complex functions
const processUserData = (
  users: UserData[],
  filters: FilterOptions
): ProcessedUserData[] => {
  return users
    .filter(user => applyFilters(user, filters))
    .map(user => transformUser(user));
};

// ✅ Type event handlers properly
const handleUserSelect = useCallback((user: UserData, event: React.MouseEvent) => {
  event.preventDefault();
  onUserSelect(user.id);
}, [onUserSelect]);
```

## Import Organization

### Import Grouping
```typescript
// 1. React and external libraries
import React, { useState, useCallback, useMemo } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { z } from "zod";

// 2. UI components (grouped by source)
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";

// 3. Shared components
import DataTable from "@/components/shared/DataTable/DataTable";
import LoadingSpinner from "@/components/shared/LoadingSpinner";

// 4. Hooks and utilities
import { cn } from "@/lib/utils";
import { formatDate } from "@/lib/date-utils";
import useEntityStore from "@/store/EntityStore";

// 5. Types and constants
import { COLUMN_TYPE, ROW_HEIGHT } from "@/types/shared";
import { UserData, ApiResponse } from "@/types/api";
```

### Import Best Practices
```typescript
// ✅ Use named imports when possible
import { Button, Input, Select } from "@/components/ui";

// ✅ Use default imports for components
import DataTable from "@/components/shared/DataTable/DataTable";

// ✅ Use namespace imports for utilities
import * as dateUtils from "@/lib/date-utils";

// ❌ Avoid: Mixed default and named imports from same module
import Button, { ButtonProps } from "@/components/ui/button"; // Confusing
```

## Naming Conventions

### File and Component Names
```typescript
// ✅ Components: PascalCase
DataTable.tsx
UserProfile.tsx
SettingsDialog.tsx

// ✅ Utilities: camelCase
dateUtils.ts
stringHelpers.ts
apiClient.ts

// ✅ Hooks: camelCase starting with 'use'
useEntityList.ts
useUserPermissions.ts
useDebounce.ts

// ✅ Types: PascalCase
UserData.ts
ApiResponse.ts
ComponentProps.ts
```

### Variable and Function Names
```typescript
// ✅ Constants: SCREAMING_SNAKE_CASE
const COLUMN_TYPE = {
  STRING: 'string',
  NUMBER: 'number',
  DATE: 'date',
} as const;

const API_ENDPOINTS = {
  USERS: '/api/v1/users',
  PROJECTS: '/api/v1/projects',
} as const;

// ✅ Event handlers: Descriptive names
const handleDeleteClick = useCallback(() => {}, []);
const handleUserSelect = useCallback((user: UserData) => {}, []);
const onModalClose = useCallback(() => {}, []);

// ❌ Avoid: Generic names
const handleClick = () => {}; // Too vague
const onSubmit = () => {};    // What is being submitted?
```

### CSS Classes
```typescript
// ✅ Use 'comet-' prefix for custom classes
className="comet-table-row-active"
className="comet-sidebar-collapsed"
className="comet-header-height"

// ✅ Use semantic Tailwind classes
className="flex items-center gap-2"
className="rounded-lg border bg-card p-6"
className="text-sm text-muted-foreground"
```

## Component Composition

### Favor Composition over Prop Drilling
```typescript
// ✅ Good: Using composition
interface DialogProps {
  children: React.ReactNode;
  title: string;
}

const Dialog: React.FC<DialogProps> = ({ children, title }) => (
  <DialogRoot>
    <DialogHeader>
      <DialogTitle>{title}</DialogTitle>
    </DialogHeader>
    <DialogContent>
      {children}
    </DialogContent>
  </DialogRoot>
);

// Usage
<Dialog title="Edit User">
  <UserForm user={selectedUser} onSave={handleSave} />
</Dialog>

// ❌ Avoid: Prop drilling
const Dialog: React.FC<{
  user: UserData;
  onSave: (user: UserData) => void;
  onCancel: () => void;
  title: string;
  // ... many more props
}> = ({ user, onSave, onCancel, title, ...manyOtherProps }) => {
  // Complex component with many responsibilities
};
```

### Custom Hooks for Logic Extraction
```typescript
// ✅ Extract common logic into custom hooks
const useEntityActions = (entityId: string) => {
  const [isDeleting, setIsDeleting] = useState(false);
  const { toast } = useToast();
  
  const deleteEntity = useCallback(async () => {
    setIsDeleting(true);
    try {
      await api.delete(`/entities/${entityId}`);
      toast({ description: "Entity deleted successfully" });
    } catch (error) {
      toast({ description: "Failed to delete entity", variant: "destructive" });
    } finally {
      setIsDeleting(false);
    }
  }, [entityId, toast]);
  
  return { deleteEntity, isDeleting };
};

// Usage in component
const EntityCard: React.FC<{ entity: Entity }> = ({ entity }) => {
  const { deleteEntity, isDeleting } = useEntityActions(entity.id);
  
  return (
    <Card>
      <CardContent>{entity.name}</CardContent>
      <CardActions>
        <Button 
          variant="destructive" 
          onClick={deleteEntity}
          disabled={isDeleting}
        >
          Delete
        </Button>
      </CardActions>
    </Card>
  );
};
```

## Code Formatting

### Prettier Configuration
```typescript
// ✅ Use trailing commas in multiline structures
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3, // <- trailing comma
};

const items = [
  "item1",
  "item2", 
  "item3", // <- trailing comma
];

// ✅ Prefer double quotes for strings
const message = "Hello, world!";
const template = `User ${userName} has logged in`;

// ✅ Use meaningful variable names
const filteredActiveUsers = users.filter(user => user.isActive);
const formattedCreationDate = formatDate(user.createdAt);
```

### Code Organization
```typescript
// ✅ Group related functionality
const UserManagement: React.FC = () => {
  // 1. State declarations
  const [selectedUser, setSelectedUser] = useState<UserData | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  
  // 2. Queries and mutations
  const { data: users, isLoading } = useUserList();
  const deleteMutation = useDeleteUser();
  
  // 3. Memoized values (only when needed)
  const activeUsers = useMemo(() => 
    users?.filter(user => user.isActive) ?? [], 
    [users]
  );
  
  // 4. Event handlers
  const handleUserSelect = useCallback((user: UserData) => {
    setSelectedUser(user);
    setIsDialogOpen(true);
  }, []);
  
  const handleDeleteUser = useCallback(async (userId: string) => {
    await deleteMutation.mutateAsync(userId);
    setIsDialogOpen(false);
  }, [deleteMutation]);
  
  // 5. Early returns
  if (isLoading) return <LoadingSpinner />;
  
  // 6. Main render
  return (
    <div className="space-y-4">
      {/* Component JSX */}
    </div>
  );
};
```