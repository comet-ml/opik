---
description: Frontend accessibility guidelines and testing patterns
globs: apps/opik-frontend/**/*
alwaysApply: false
---

# Accessibility & Testing Guidelines

## Accessibility Guidelines

### Semantic HTML

```typescript
// ✅ Use semantic HTML elements
<header className="comet-header">
  <nav>
    <ul>
      <li><a href="/dashboard">Dashboard</a></li>
      <li><a href="/projects">Projects</a></li>
    </ul>
  </nav>
</header>

<main className="comet-content">
  <section>
    <h1>Page Title</h1>
    <article>
      {/* Content */}
    </article>
  </section>
</main>

// ❌ Avoid: Generic divs for everything
<div className="header">
  <div className="nav">
    <div className="nav-item">Dashboard</div>
  </div>
</div>
```

### ARIA Labels and Descriptions

```typescript
// ✅ Always provide aria-label for icon buttons
<Button variant="ghost" size="icon" aria-label="Delete item">
  <TrashIcon />
</Button>

<Button variant="outline" aria-label="Sort by name">
  <SortIcon />
  Sort
</Button>

// ✅ Use aria-describedby for additional context
<Input
  id="email"
  type="email"
  aria-describedby="email-help"
  {...field}
/>
<div id="email-help" className="text-sm text-muted-foreground">
  We'll never share your email address
</div>

// ✅ Use aria-expanded for collapsible content
<Button
  aria-expanded={isOpen}
  aria-controls="dropdown-menu"
  onClick={() => setIsOpen(!isOpen)}
>
  Options
</Button>
<div id="dropdown-menu" hidden={!isOpen}>
  {/* Menu content */}
</div>
```

### Keyboard Navigation

```typescript
// ✅ Ensure keyboard navigation works
const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
  if (event.key === 'Enter' || event.key === ' ') {
    event.preventDefault();
    handleAction();
  } else if (event.key === 'Escape') {
    event.preventDefault();
    handleClose();
  }
}, [handleAction, handleClose]);

<div
  role="button"
  tabIndex={0}
  onKeyDown={handleKeyDown}
  onClick={handleAction}
  className="cursor-pointer focus:outline-none focus:ring-2 focus:ring-primary"
>
  Clickable Content
</div>
```

### Focus Management

```typescript
// ✅ Provide visible focus indicators
.focus-visible:focus {
  @apply ring-2 ring-primary ring-offset-2;
}

// ✅ Use focus trap in modals
import { FocusTrap } from '@radix-ui/react-focus-trap';

<Dialog open={isOpen} onOpenChange={setIsOpen}>
  <DialogContent>
    <FocusTrap>
      <div>
        <DialogHeader>
          <DialogTitle>Modal Title</DialogTitle>
        </DialogHeader>
        {/* Modal content */}
      </div>
    </FocusTrap>
  </DialogContent>
</Dialog>
```

### Heading Hierarchy

```typescript
// ✅ Use proper heading hierarchy
<div className="page">
  <h1>Dashboard</h1>

  <section>
    <h2>Recent Projects</h2>

    <article>
      <h3>Project Name</h3>
      <p>Project description...</p>
    </article>
  </section>

  <section>
    <h2>System Status</h2>

    <div>
      <h3>Database</h3>
      <p>Status: Online</p>
    </div>
  </section>
</div>

// ❌ Avoid: Skipping heading levels
<h1>Page Title</h1>
<h4>Subsection</h4> {/* Skips h2, h3 */}
```

### Loading States and Error Messages

```typescript
// ✅ Include accessible loading states
{isLoading && (
  <div role="status" aria-live="polite">
    <Spinner className="mr-2" />
    <span className="sr-only">Loading data...</span>
    Loading...
  </div>
)}

// ✅ Include accessible error messages
{error && (
  <Alert variant="destructive" role="alert">
    <AlertCircle className="h-4 w-4" />
    <AlertTitle>Error</AlertTitle>
    <AlertDescription>
      {error.message || "Something went wrong. Please try again."}
    </AlertDescription>
  </Alert>
)}
```

## Testing Patterns

### Component Testing with React Testing Library

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserProfile } from './UserProfile';

describe('UserProfile', () => {
  const mockUser = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com',
  };

  it('renders user information correctly', () => {
    render(<UserProfile user={mockUser} />);

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('allows editing user name', async () => {
    const user = userEvent.setup();
    const onSave = jest.fn();

    render(<UserProfile user={mockUser} onSave={onSave} />);

    const editButton = screen.getByRole('button', { name: /edit/i });
    await user.click(editButton);

    const nameInput = screen.getByLabelText(/name/i);
    await user.clear(nameInput);
    await user.type(nameInput, 'Jane Doe');

    const saveButton = screen.getByRole('button', { name: /save/i });
    await user.click(saveButton);

    await waitFor(() => {
      expect(onSave).toHaveBeenCalledWith({
        ...mockUser,
        name: 'Jane Doe',
      });
    });
  });
});
```

### Custom Hook Testing

```typescript
import { renderHook, act } from "@testing-library/react";
import { useEntityList } from "./useEntityList";

describe("useEntityList", () => {
  it("fetches entities successfully", async () => {
    const mockData = {
      content: [{ id: "1", name: "Entity 1" }],
      total: 1,
    };

    // Mock API call
    jest.mocked(api.get).mockResolvedValue({ data: mockData });

    const { result } = renderHook(() =>
      useEntityList({ workspaceName: "test", page: 1, size: 10 }),
    );

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(mockData);
  });
});
```

### API Mocking with MSW

```typescript
// src/mocks/handlers.ts
import { rest } from "msw";

export const handlers = [
  rest.get("/api/v1/entities", (req, res, ctx) => {
    return res(
      ctx.json({
        content: [
          { id: "1", name: "Entity 1" },
          { id: "2", name: "Entity 2" },
        ],
        total: 2,
      }),
    );
  }),

  rest.delete("/api/v1/entities/:id", (req, res, ctx) => {
    return res(ctx.status(204));
  }),
];

// In test files
import { server } from "../mocks/server";

beforeEach(() => {
  server.listen();
});

afterEach(() => {
  server.resetHandlers();
});

afterAll(() => {
  server.close();
});
```

### Integration Testing

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { EntityListPage } from './EntityListPage';

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('EntityListPage Integration', () => {
  it('loads and displays entities', async () => {
    render(<EntityListPage />, { wrapper: createWrapper() });

    // Wait for loading to complete
    await waitFor(() => {
      expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
    });

    // Check if entities are displayed
    expect(screen.getByText('Entity 1')).toBeInTheDocument();
    expect(screen.getByText('Entity 2')).toBeInTheDocument();
  });

  it('handles entity deletion flow', async () => {
    const user = userEvent.setup();
    render(<EntityListPage />, { wrapper: createWrapper() });

    await waitFor(() => {
      expect(screen.getByText('Entity 1')).toBeInTheDocument();
    });

    // Find and click delete button
    const deleteButton = screen.getByRole('button', { name: /delete entity 1/i });
    await user.click(deleteButton);

    // Confirm deletion
    const confirmButton = screen.getByRole('button', { name: /confirm/i });
    await user.click(confirmButton);

    // Check if entity is removed
    await waitFor(() => {
      expect(screen.queryByText('Entity 1')).not.toBeInTheDocument();
    });
  });
});
```

## Testing Best Practices

1. **Test user interactions, not implementation details**
2. **Use `screen.getByRole` over `getByTestId` when possible**
3. **Write integration tests for complex user flows**
4. **Mock API calls consistently**
5. **Test accessibility features**
6. **Test error scenarios and edge cases**

```typescript
// ✅ Good: Testing behavior
expect(screen.getByRole("button", { name: /save/i })).toBeEnabled();

// ❌ Avoid: Testing implementation
expect(component.state.isSaving).toBe(false);

// ✅ Good: Testing accessibility
expect(screen.getByLabelText(/email address/i)).toBeInTheDocument();

// ✅ Good: Testing error states
await user.click(submitButton);
expect(screen.getByRole("alert")).toHaveTextContent("Email is required");
```
