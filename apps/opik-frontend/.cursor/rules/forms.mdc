---
description: Frontend form handling patterns using React Hook Form and Zod
globs: "**/*"
alwaysApply: false
---

# Form Handling Patterns

## React Hook Form + Zod Pattern

### Basic Form Setup
```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

// Define schema
const formSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Invalid email"),
  description: z.string().optional(),
});

type FormData = z.infer<typeof formSchema>;

// Use in component
const form = useForm<FormData>({
  resolver: zodResolver(formSchema),
  defaultValues: {
    name: "",
    email: "",
    description: "",
  },
});

const onSubmit = useCallback((data: FormData) => {
  // Handle form submission
  console.log(data);
}, []);
```

### Form JSX Structure
```typescript
<Form {...form}>
  <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
    <FormField
      control={form.control}
      name="name"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Name</FormLabel>
          <FormControl>
            <Input {...field} />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
    
    <FormField
      control={form.control}
      name="email"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Email</FormLabel>
          <FormControl>
            <Input type="email" {...field} />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
    
    <Button type="submit" disabled={form.formState.isSubmitting}>
      {form.formState.isSubmitting && <Spinner className="mr-2" />}
      Submit
    </Button>
  </form>
</Form>
```

## Advanced Form Patterns

### Dynamic Form Fields
```typescript
const formSchema = z.object({
  items: z.array(z.object({
    name: z.string().min(1, "Name is required"),
    value: z.string().min(1, "Value is required"),
  })).min(1, "At least one item is required"),
});

const { fields, append, remove } = useFieldArray({
  control: form.control,
  name: "items",
});

// In JSX
{fields.map((field, index) => (
  <div key={field.id} className="flex gap-2">
    <FormField
      control={form.control}
      name={`items.${index}.name`}
      render={({ field }) => (
        <FormItem>
          <FormControl>
            <Input {...field} placeholder="Name" />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
    
    <Button 
      type="button" 
      variant="outline" 
      onClick={() => remove(index)}
    >
      Remove
    </Button>
  </div>
))}

<Button 
  type="button" 
  onClick={() => append({ name: "", value: "" })}
>
  Add Item
</Button>
```

### Conditional Validation
```typescript
const formSchema = z.object({
  type: z.enum(["user", "admin"]),
  permissions: z.array(z.string()).optional(),
}).refine((data) => {
  // Conditional validation: admin must have permissions
  if (data.type === "admin" && (!data.permissions || data.permissions.length === 0)) {
    return false;
  }
  return true;
}, {
  message: "Admin users must have at least one permission",
  path: ["permissions"],
});
```

### Custom Field Components
```typescript
// Custom field wrapper
interface CustomFieldProps {
  name: string;
  label: string;
  description?: string;
  required?: boolean;
  children: (field: any) => React.ReactNode;
}

const CustomField: React.FC<CustomFieldProps> = ({
  name,
  label,
  description,
  required,
  children,
}) => {
  const form = useFormContext();
  
  return (
    <FormField
      control={form.control}
      name={name}
      render={({ field }) => (
        <FormItem>
          <FormLabel>
            {label} {required && <span className="text-destructive">*</span>}
          </FormLabel>
          <FormControl>
            {children(field)}
          </FormControl>
          {description && (
            <FormDescription>{description}</FormDescription>
          )}
          <FormMessage />
        </FormItem>
      )}
    />
  );
};

// Usage
<CustomField
  name="email"
  label="Email Address"
  description="We'll never share your email"
  required
>
  {(field) => <Input type="email" {...field} />}
</CustomField>
```

## Form State Management

### Loading and Error States
```typescript
const [isSubmitting, setIsSubmitting] = useState(false);
const [submitError, setSubmitError] = useState<string | null>(null);

const onSubmit = useCallback(async (data: FormData) => {
  setIsSubmitting(true);
  setSubmitError(null);
  
  try {
    await submitForm(data);
    toast({ description: "Form submitted successfully!" });
    form.reset();
  } catch (error) {
    setSubmitError(error.message);
    toast({ 
      description: "Failed to submit form", 
      variant: "destructive" 
    });
  } finally {
    setIsSubmitting(false);
  }
}, [form, toast]);

// In JSX
{submitError && (
  <Alert variant="destructive">
    <AlertDescription>{submitError}</AlertDescription>
  </Alert>
)}

<Button type="submit" disabled={isSubmitting}>
  {isSubmitting && <Spinner className="mr-2" />}
  Submit
</Button>
```

### Form Reset and Default Values
```typescript
// Reset form to default values
const handleReset = useCallback(() => {
  form.reset();
}, [form]);

// Reset with new default values
const handleResetWithData = useCallback((newData: Partial<FormData>) => {
  form.reset(newData);
}, [form]);

// Watch for changes
const watchedValues = form.watch();
const specificField = form.watch("name");

useEffect(() => {
  // React to form changes
  console.log("Form values changed:", watchedValues);
}, [watchedValues]);
```

## Validation Patterns

### Custom Validators
```typescript
const phoneSchema = z.string().refine((val) => {
  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
  return phoneRegex.test(val);
}, {
  message: "Invalid phone number format",
});

// Async validation
const emailSchema = z.string().email().refine(async (email) => {
  const isAvailable = await checkEmailAvailability(email);
  return isAvailable;
}, {
  message: "Email is already taken",
});
```

### Multi-step Forms
```typescript
const steps = [
  { name: "Personal Info", schema: personalInfoSchema },
  { name: "Contact Details", schema: contactSchema },
  { name: "Preferences", schema: preferencesSchema },
];

const [currentStep, setCurrentStep] = useState(0);
const currentSchema = steps[currentStep].schema;

const form = useForm({
  resolver: zodResolver(currentSchema),
  defaultValues: formData,
});

const handleNext = useCallback(async () => {
  const isValid = await form.trigger();
  if (isValid) {
    setCurrentStep(prev => Math.min(prev + 1, steps.length - 1));
  }
}, [form]);

const handlePrevious = useCallback(() => {
  setCurrentStep(prev => Math.max(prev - 1, 0));
}, []);
```