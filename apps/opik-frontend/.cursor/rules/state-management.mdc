---
description: Frontend state management patterns using Zustand and local storage
globs: apps/opik-frontend/**/*
alwaysApply: false
---

# State Management Patterns

## Zustand Store Pattern

### Store Structure

```typescript
// File: src/store/EntityStore.ts
import { create } from "zustand";

type EntityState = {
  selectedEntity: Entity | null;
  filters: FilterState;
};

type EntityActions = {
  setSelectedEntity: (entity: Entity | null) => void;
  updateFilters: (filters: Partial<FilterState>) => void;
  resetFilters: () => void;
};

type EntityStore = EntityState & EntityActions;

const useEntityStore = create<EntityStore>((set) => ({
  // State
  selectedEntity: null,
  filters: defaultFilters,

  // Actions
  setSelectedEntity: (entity) => set({ selectedEntity: entity }),
  updateFilters: (newFilters) =>
    set((state) => ({ filters: { ...state.filters, ...newFilters } })),
  resetFilters: () => set({ filters: defaultFilters }),
}));

// Exported selectors
export const useSelectedEntity = () =>
  useEntityStore((state) => state.selectedEntity);
export const useEntityFilters = () => useEntityStore((state) => state.filters);

export default useEntityStore;
```

### Store Best Practices

1. **Separate State from Actions**: Keep clear separation between state and action types
2. **Use Selectors**: Export individual selectors for better component performance
3. **Immutable Updates**: Always use immutable update patterns
4. **TypeScript**: Define comprehensive types for state and actions

```typescript
// ✅ Good: Using selectors
const selectedEntity = useSelectedEntity();
const filters = useEntityFilters();

// ❌ Avoid: Selecting entire store
const { selectedEntity, filters } = useEntityStore();
```

## Local Storage Integration

### Using use-local-storage-state

```typescript
// Use use-local-storage-state for persistence
import useLocalStorageState from "use-local-storage-state";

const [preferences, setPreferences] = useLocalStorageState("userPreferences", {
  defaultValue: {
    theme: "light",
    sidebarCollapsed: false,
    tablePageSize: 10,
  },
});

// Update specific preference
const updatePreference = useCallback(
  (key: string, value: any) => {
    setPreferences((prev) => ({ ...prev, [key]: value }));
  },
  [setPreferences],
);
```

### Local Storage Patterns

```typescript
// ✅ Good: Type-safe local storage
interface UserPreferences {
  theme: "light" | "dark";
  sidebarCollapsed: boolean;
  tablePageSize: number;
}

const [preferences, setPreferences] = useLocalStorageState<UserPreferences>(
  "userPreferences",
  {
    defaultValue: {
      theme: "light",
      sidebarCollapsed: false,
      tablePageSize: 10,
    },
  },
);

// ❌ Avoid: Untyped local storage
const [prefs, setPrefs] = useLocalStorageState("prefs", {
  defaultValue: {},
});
```

## State Composition Patterns

### Combining Multiple Stores

```typescript
// Use multiple focused stores instead of one large store
const useUIStore = create<UIState>((set) => ({
  sidebarOpen: true,
  modalOpen: false,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
}));

const useDataStore = create<DataState>((set) => ({
  entities: [],
  selectedId: null,
  setEntities: (entities) => set({ entities }),
}));

// In components, use multiple stores
const Component = () => {
  const sidebarOpen = useUIStore((state) => state.sidebarOpen);
  const entities = useDataStore((state) => state.entities);

  return <div>{/* Component JSX */}</div>;
};
```

### Context for Component Trees

```typescript
// Use context sparingly, prefer prop passing
interface ComponentContextValue {
  theme: string;
  locale: string;
}

const ComponentContext = createContext<ComponentContextValue | null>(null);

const useComponentContext = () => {
  const context = useContext(ComponentContext);
  if (!context) {
    throw new Error('useComponentContext must be used within ComponentProvider');
  }
  return context;
};

// ✅ Good: Context for widely-used values
<ComponentContext.Provider value={{ theme, locale }}>
  <ComponentTree />
</ComponentContext.Provider>

// ❌ Avoid: Context for frequently changing data
// Use Zustand or props instead
```

## State Synchronization

### Syncing with URL State

```typescript
import { useNavigate, useSearch } from "@tanstack/react-router";

const EntityListPage = () => {
  const navigate = useNavigate();
  const { page, search, sortBy } = useSearch({ strict: false });

  const updateUrl = useCallback((updates: Partial<SearchParams>) => {
    navigate({
      search: (prev) => ({ ...prev, ...updates }),
    });
  }, [navigate]);

  const handlePageChange = useCallback((newPage: number) => {
    updateUrl({ page: newPage });
  }, [updateUrl]);

  return <div>{/* Component JSX */}</div>;
};
```

### Syncing Stores with Server State

```typescript
// Sync Zustand store with React Query data
const useEntitySync = () => {
  const setEntities = useEntityStore((state) => state.setEntities);
  const { data } = useEntityList();

  useEffect(() => {
    if (data?.content) {
      setEntities(data.content);
    }
  }, [data?.content, setEntities]);
};
```

## Performance Considerations

1. **Selective Subscriptions**: Use specific selectors to prevent unnecessary re-renders
2. **Shallow Equality**: Zustand uses Object.is by default; use shallow for objects
3. **Action Memoization**: Memoize action creators when passing to children

```typescript
// ✅ Good: Shallow comparison for objects
import { shallow } from "zustand/shallow";

const { filters, selectedEntity } = useEntityStore(
  (state) => ({ filters: state.filters, selectedEntity: state.selectedEntity }),
  shallow,
);

// ✅ Good: Memoized actions
const actions = useMemo(
  () => ({
    updateFilters: useEntityStore.getState().updateFilters,
    resetFilters: useEntityStore.getState().resetFilters,
  }),
  [],
);
```
