---
description: Frontend performance optimization rules for React hooks and data processing
globs: apps/opik-frontend/**/*
alwaysApply: false
---

# Frontend Performance Guidelines

## Selective useMemo Usage

**Use useMemo ONLY for:**

- Complex computations that are expensive to recalculate
- Data transformations with multiple operations or iterations
- Large array filtering/sorting operations
- Object/array creation that would cause unnecessary child re-renders

```typescript
// ✅ Good: Complex computation
const expensiveValue = useMemo(() => {
  return largeDataSet
    .filter((item) => item.category === selectedCategory)
    .sort((a, b) => a.date.localeCompare(b.date))
    .map((item) => transformItem(item));
}, [largeDataSet, selectedCategory]);

// ✅ Good: API data transformation for child components
const rows = useMemo(() => data?.content ?? [], [data?.content]);

// ❌ Avoid: Simple fallbacks that don't need memoization
const items = data?.content ?? []; // This is fine without useMemo

// ❌ Avoid: Primitive values or simple operations
const isVisible = useMemo(() => showModal, [showModal]); // Unnecessary
```

## Selective useCallback Usage

**Use useCallback ONLY for:**

- Functions passed as props to child components
- Functions used in useEffect dependencies
- Event handlers in frequently re-rendering components
- Functions that have complex logic or closures

```typescript
// ✅ Good: Function passed to child component
const handleItemSelect = useCallback(
  (id: string) => {
    setSelectedItem(id);
    onSelectionChange?.(id);
  },
  [onSelectionChange],
);

// ✅ Good: Function used in effect dependency
const fetchData = useCallback(async () => {
  const result = await api.getData(filters);
  setData(result);
}, [filters]);

useEffect(() => {
  fetchData();
}, [fetchData]);

// ❌ Avoid: Simple inline handlers not passed to children
const handleClick = () => setCount(count + 1); // This is fine without useCallback

// ❌ Avoid: Functions only used locally in component
const processValue = useCallback((value) => value.toUpperCase(), []); // Unnecessary
```

## Data Processing Patterns

### API Response Handling

```typescript
// ✅ For complex transformations
const processedItems = useMemo(() => {
  return (
    data?.content
      ?.filter((item) => item.status === "active")
      ?.map((item) => ({
        ...item,
        displayName: `${item.firstName} ${item.lastName}`,
        formattedDate: formatDate(item.createdAt),
      })) ?? []
  );
}, [data?.content]);

// ✅ For simple fallbacks
const items = data?.content ?? []; // No useMemo needed
const totalCount = data?.total ?? 0; // No useMemo needed
```

### Column Definitions

```typescript
// ✅ Memoize complex column definitions
const columns: ColumnDef<DataType>[] = useMemo(() => [
  {
    id: "name",
    accessorKey: "name",
    header: "Name",
    cell: ({ row }) => <CustomCell data={row.original} />,
    meta: { type: COLUMN_TYPE.string },
  },
  // ... more complex columns
], []);

// ❌ Don't memoize if columns never change
const simpleColumns = [
  { id: "id", accessorKey: "id", header: "ID" },
  { id: "name", accessorKey: "name", header: "Name" },
];
```

## Performance Best Practices

1. **Measure before optimizing** - Use React DevTools Profiler
2. **Avoid premature optimization** - Add memoization only when needed
3. **Use lazy loading** for large components/routes
4. **Prefer pagination** over infinite scrolling for large datasets
5. **Avoid inline functions** in JSX props when passing to children

```typescript
// ✅ Good: Function not passed to children
<button onClick={() => setOpen(true)}>Open</button>

// ❌ Bad: Inline function passed to child component
<ChildComponent onAction={() => doSomething()} />

// ✅ Good: Memoized function for child component
const handleAction = useCallback(() => doSomething(), []);
<ChildComponent onAction={handleAction} />
```

## When NOT to Use Hooks

- Simple primitive values or direct property access
- Functions that are only called locally within the component
- Values that change on every render anyway
- Simple object/array literals that don't impact child components
