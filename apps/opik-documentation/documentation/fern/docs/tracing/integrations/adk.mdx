[Agent Development Kit (ADK)](https://google.github.io/adk-docs/) is a flexible and modular framework for developing and deploying AI agents. ADK can be used with popular LLMs and open-source generative AI tools and is designed with a focus on tight integration with the Google ecosystem and Gemini models. ADK makes it easy to get started with simple agents powered by Gemini models and Google AI tools while providing the control and structure needed for more complex agent architectures and orchestration.

Opik provides comprehensive integration with ADK, automatically logging traces for all agent executions, tool calls, and LLM interactions with detailed cost tracking and error monitoring.

## Key Features

- **Automatic cost tracking** for all supported LLM providers including LiteLLM models (OpenAI, Anthropic, Google AI, AWS Bedrock, and more)
- **Full compatibility** with the `@opik.track` decorator for hybrid tracing approaches
- **Thread support** for conversational applications using ADK sessions
- **Automatic agent graph visualization** with Mermaid diagrams for complex multi-agent workflows
- **Comprehensive error tracking** with detailed error information and stack traces
- **Multi-agent instrumentation** with `track_adk_agent_recursive` for complex agent hierarchies

## Getting started

First, ensure you have both `opik` and `google-adk` installed:

```bash
pip install opik google-adk
```

You can also set up Opik by using the `opik configure` CLI command. This will ask you to enter either your local server address or your API key if you're using the Cloud version:

```bash
opik configure
```

## Using OpikTracer

The [`OpikTracer`](https://www.comet.com/docs/opik/python-sdk-reference/integrations/adk/OpikTracer.html) automatically captures detailed information about your ADK agent executions, including inputs, outputs, metadata, token usage, and error information. Here's a basic example:

```python
import datetime
from zoneinfo import ZoneInfo

from google.adk.agents import Agent
from opik.integrations.adk import OpikTracer


def get_weather(city: str) -> dict:
    if city.lower() == "new york":
        return {
            "status": "success",
            "report": (
                "The weather in New York is sunny with a temperature of 25 degrees"
                " Celsius (41 degrees Fahrenheit)."
            ),
        }
    else:
        return {
            "status": "error",
            "error_message": f"Weather information for '{city}' is not available.",
        }


def get_current_time(city: str) -> dict:
    if city.lower() == "new york":
        tz_identifier = "America/New_York"
    else:
        return {
            "status": "error",
            "error_message": (f"Sorry, I don't have timezone information for {city}."),
        }

    tz = ZoneInfo(tz_identifier)
    now = datetime.datetime.now(tz)
    report = f'The current time in {city} is {now.strftime("%Y-%m-%d %H:%M:%S %Z%z")}'
    return {"status": "success", "report": report}


opik_tracer = OpikTracer()

root_agent = Agent(
    name="weather_time_agent",
    model="gemini-2.5-flash",
    description=("Agent to answer questions about the time and weather in a city."),
    instruction=("I can answer your questions about the time and weather in a city."),
    tools=[get_weather, get_current_time],
    before_agent_callback=opik_tracer.before_agent_callback,
    after_agent_callback=opik_tracer.after_agent_callback,
    before_model_callback=opik_tracer.before_model_callback,
    after_model_callback=opik_tracer.after_model_callback,
    before_tool_callback=opik_tracer.before_tool_callback,
    after_tool_callback=opik_tracer.after_tool_callback,
)
```

Each agent execution will now be automatically logged to the Opik platform with the detailed trace information:

<Frame>
  <img src="/img/tracing/adk/adk_weather_time_trace_screenshot.png" />
</Frame>

## Multi-agent instrumentation with track_adk_agent_recursive

For complex multi-agent systems, manually adding OpikTracer callbacks to every agent can be time-consuming. The [`track_adk_agent_recursive`](https://www.comet.com/docs/opik/python-sdk-reference/integrations/adk/track_adk_agent_recursive.html) function automatically adds OpikTracer callbacks to all agents in your hierarchy:

```python
from opik.integrations.adk import OpikTracer, track_adk_agent_recursive
from google.adk import agents as adk_agents

opik_tracer = OpikTracer(project_name="multi-agent-system")

# Create a complex multi-agent system
translator_to_english = adk_agents.Agent(
    name="Translator",
    model="gemini-2.5-flash",
    description="Translates text to English.",
)

summarizer = adk_agents.Agent(
    name="Summarizer", 
    model="gemini-2.5-flash",
    description="Summarizes text to 1 sentence.",
)

root_agent = adk_agents.SequentialAgent(
    name="TextProcessingAssistant",
    sub_agents=[translator_to_english, summarizer],
    description="Runs translator to english then summarizer, in order.",
)

# Automatically instrument all agents in the hierarchy
track_adk_agent_recursive(root_agent, opik_tracer)

# Now all agents will be automatically tracked
```

This approach is particularly useful for:
- **Sequential agents** with multiple processing steps
- **Parallel agents** executing tasks concurrently  
- **Loop agents** with iterative workflows
- **Agent tools** that contain nested agents
- **Complex hierarchies** with deeply nested agent structures

## Cost Tracking

Opik automatically tracks token usage and cost for all LLM calls during the agent execution, not only for the Gemini LLMs, but including the models accessed via `LiteLLM`.

<Tip>
  View the complete list of supported models and providers on the [Supported Models](/tracing/supported_models) page.
</Tip>

## Agent Graph Visualization

Opik automatically generates visual representations of your agent workflows using Mermaid diagrams. The graph shows:

- **Agent hierarchy** and relationships
- **Sequential execution** flows
- **Parallel processing** branches  
- **Loop structures** and iterations
- **Tool connections** and dependencies

The graph is automatically computed and stored with each trace, providing a clear visual understanding of your agent's execution flow:

For weather time agent the graph will look like that:

<Frame>
  <img src="/img/tracing/adk/adk_weather_time_graph_screenshot.png" />
</Frame>

For more complex agent architectures displaying a graph may be even more beneficial:

<Frame>
  <img src="/img/tracing/adk/adk_code_assistant_graph_screenshot.png" />
</Frame>

## Compatibility with @opik.track Decorator

The `OpikTracer` is fully compatible with the `@track` decorator, allowing you to create hybrid tracing approaches that combine ADK agent tracking with custom function tracing.
You can both invoke your agent from inside another tracked function and call tracked functions inside your tool functions, all the spans and traces parent-child relationships will be preserved!


## Thread Support

The Opik integration automatically handles ADK sessions and maps them to Opik threads for conversational applications:

```python
from opik.integrations.adk import OpikTracer
from google.adk import sessions as adk_sessions, runners as adk_runners

# ADK session management
session_service = adk_sessions.InMemorySessionService()
session = session_service.create_session_sync(
    app_name="my_app",
    user_id="user_123", 
    session_id="conversation_456"
)

opik_tracer = OpikTracer()
runner = adk_runners.Runner(
    agent=your_agent,
    app_name="my_app", 
    session_service=session_service
)

# All traces will be automatically grouped by session_id as thread_id
```

The integration automatically:
- Uses the ADK session ID as the Opik thread ID
- Groups related conversations and interactions
- Logs app_name and user_id as metadata
- Maintains conversation context across multiple interactions

## Error Tracking

The `OpikTracer` provides comprehensive error tracking and monitoring:

- **Automatic error capture** for agent execution failures
- **Detailed stack traces** with full context information
- **Tool execution errors** with input/output data
- **Model call failures** with provider-specific error details
- **Graceful error handling** that doesn't interrupt agent execution

Error information is automatically logged to spans and traces, making it easy to debug issues in production:

<Frame>
  <img src="/img/tracing/adk/adk_error_propagation_screenshot.png" />
</Frame>

## Troubleshooting: Missing Trace

When using `Runner.run_async`, make sure to process all events completely, even after finding the final response (when `event.is_final_response()` is `True`). If you exit the loop too early, OpikTracer won't log the final response and your trace will be incomplete. Don't use code that stops processing events prematurely:

```python
async for event in runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
    if event.is_final_response():
        ...
        break  # Stop processing events once the final response is found
```

There is an upstream discussion about how to best solve this source of confusion: https://github.com/google/adk-python/issues/1695.
<Tip>
  Our team tried to address those issues and make the integration as robust as possible. If you are facing similar problems, the first thing we recommend is to update both `opik` and `google-adk` to the latest versions. We are actively working on improving this integration, so with the most recent versions you'll most likely get the best UX!.
</Tip>

## Flushing Traces

The `OpikTracer` object has a `flush` method that ensures all traces are logged to the Opik platform before you exit a script:

```python
from opik.integrations.adk import OpikTracer

opik_tracer = OpikTracer()

# Your ADK agent execution code here...

# Ensure all traces are sent before script exits
opik_tracer.flush()
```