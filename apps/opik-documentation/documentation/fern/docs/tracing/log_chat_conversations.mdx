You can log chat conversations to the Opik platform and track the full conversations
your users are having with your chatbot. Threads allow you to group related traces together, creating a conversational flow that makes it easy to review multi-turn interactions and track user sessions.

<Frame>
  <img src="/img/tracing/chat_conversations.png" />
</Frame>

## Understanding Threads

Threads in Opik are collections of traces that are grouped together using a unique `thread_id`. This is particularly useful for:

- **Multi-turn conversations**: Track complete chat sessions between users and AI assistants
- **User sessions**: Group all interactions from a single user session
- **Conversational agents**: Follow the flow of agent interactions and tool usage
- **Workflow tracking**: Monitor complex workflows that span multiple function calls

The `thread_id` is a user-defined identifier that must be unique per project. All traces with the same `thread_id` will be grouped together and displayed as a single conversation thread in the Opik UI.

## Logging conversations

You can log chat conversations by specifying the `thread_id` parameter when using either the low level SDK, Python decorators, or integration libraries:

<Tabs>
    <Tab title="Python decorators" value="Python decorators">
    ```python
    import opik
    from opik import opik_context

    @opik.track
    def chat_message(input, thread_id):
        opik_context.update_current_trace(
            thread_id=thread_id
        )
        return "Opik is an Open Source GenAI platform"

    thread_id = "f174a"
    chat_message("What is Opik ?", thread_id)
    chat_message("Repeat the previous message", thread_id)
    ```
    </Tab>
    <Tab title="Low level SDK" value="Low level SDK">
    ```python
    import opik

    opik_client = opik.Opik()

    thread_id = "55d84"

    # Log a first message
    trace = opik_client.trace(
        name="chat_conversation",
        input="What is Opik?",
        output="Opik is an Open Source GenAI platform",
        thread_id=thread_id
    )

    # Log a second message
    trace = opik_client.trace(
        name="chat_conversation",
        input="Can you track chat conversations in Opik",
        output="Yes, of course !",
        thread_id=thread_id
    )
    ```
    </Tab>
    <Tab title="Integration libraries" value="Integration libraries">
    ```python
    # Using LangChain integration
    from langchain_openai import ChatOpenAI
    from opik.integrations.langchain import OpikTracer

    # Create tracer with thread_id for conversation tracking
    opik_tracer = OpikTracer(
        project_name="chatbot-conversations",
        thread_id="user-session-789"
    )

    llm = ChatOpenAI(model="gpt-4o")

    # First message in conversation
    response1 = llm.invoke(
        "What is machine learning?",
        config={"callbacks": [opik_tracer]}
    )

    # Follow-up message in same conversation
    response2 = llm.invoke(
        "Can you give me a simple example?",
        config={"callbacks": [opik_tracer]}
    )
    ```
    </Tab>

</Tabs>

<Note>
  The input to each trace will be displayed as the user message while the output will be displayed as the AI assistant
  response.
</Note>

## Thread ID Best Practices

### Generating Thread IDs

Choose a thread ID strategy that fits your application:

<Tabs>
    <Tab title="User session based" value="User session based">
    ```python
    import uuid
    import opik

    # Generate unique thread ID per user session
    user_id = "user_12345"
    session_start_time = "2024-01-15T10:30:00Z"
    thread_id = f"{user_id}-{session_start_time}"

    @opik.track
    def process_user_message(message, user_id):
        from opik import opik_context
        opik_context.update_current_trace(thread_id=thread_id)
        # Process message
        return "Response to: " + message
    ```
    </Tab>
    <Tab title="UUID based" value="UUID based">
    ```python
    import uuid
    import opik

    # Generate random UUID for each conversation
    thread_id = str(uuid.uuid4())  # e.g., "f47ac10b-58cc-4372-a567-0e02b2c3d479"

    @opik.track
    def start_conversation(initial_message):
        from opik import opik_context
        opik_context.update_current_trace(thread_id=thread_id)
        return f"Processing: {initial_message}"
    ```
    </Tab>
    <Tab title="Timestamp based" value="Timestamp based">
    ```python
    import time
    import opik

    # Use timestamp for time-based grouping
    thread_id = f"conversation-{int(time.time())}"

    @opik.track
    def handle_conversation_turn(message):
        from opik import opik_context
        opik_context.update_current_trace(thread_id=thread_id)
        return f"Response to: {message}"
    ```
    </Tab>

</Tabs>

### Integration-Specific Threading

Different integrations handle thread IDs in various ways:

#### LangChain Integration

```python
from opik.integrations.langchain import OpikTracer

# Set thread_id at tracer level - applies to all traces
opik_tracer = OpikTracer(
    project_name="my-chatbot",
    thread_id="conversation-123"
)

# Or pass dynamically via metadata
chain.invoke(
    {"input": "Hello"},
    config={
        "callbacks": [opik_tracer],
        "metadata": {"thread_id": "dynamic-conversation-456"}
    }
)
```

#### LangGraph Integration

```python
from opik.integrations.langchain import OpikTracer

# LangGraph automatically uses its thread_id as Opik thread_id
thread_id = "langgraph-conversation-789"
config = {
    "callbacks": [OpikTracer()],
    "configurable": {"thread_id": thread_id}
}

result = compiled_graph.invoke(input_data, config=config)
```

#### OpenAI Agents Integration

```python
import uuid
from opik import trace

# Use trace context manager with group_id for threading
thread_id = str(uuid.uuid4())

with trace(workflow_name="Agent Conversation", group_id=thread_id):
    # All agent interactions within this context share the thread_id
    result1 = await Runner.run(agent, "First question")
    result2 = await Runner.run(agent, "Follow-up question")
```

### Thread Management in Production

For production applications, consider these patterns:

```python
import opik
from datetime import datetime, timedelta

class ConversationManager:
    def __init__(self):
        self.active_threads = {}
        self.opik_client = opik.Opik()

    def get_or_create_thread_id(self, user_id: str, session_id: str = None) -> str:
        """Generate or retrieve thread ID for user session"""
        if session_id:
            thread_id = f"{user_id}-{session_id}"
        else:
            thread_id = f"{user_id}-{datetime.now().isoformat()}"

        self.active_threads[thread_id] = datetime.now()
        return thread_id

    @opik.track
    def process_message(self, user_id: str, message: str, thread_id: str = None):
        if not thread_id:
            thread_id = self.get_or_create_thread_id(user_id)

        # Update current trace with thread_id
        opik_context.update_current_trace(
            thread_id=thread_id,
            metadata={
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        )

        # Process the message
        response = f"AI response to: {message}"
        return response

    def generate_response(self, message: str) -> str:
        """Generate AI response to user message"""
        return f"AI response to: {message}"

    def cleanup_old_threads(self, hours: int = 24):
        """Remove thread IDs older than specified hours"""
        cutoff = datetime.now() - timedelta(hours=hours)
        self.active_threads = {
            tid: timestamp for tid, timestamp in self.active_threads.items()
            if timestamp > cutoff
        }
```

## Reviewing conversations

Conversations can be viewed at a project level in the `threads` tab. All conversations are tracked and by clicking on the thread ID you will be able to
view the full conversation.

The thread view supports markdown making it easier for you to review the content that was returned to the user. If you would like to dig in deeper, you
can click on the `View trace` button to deepdive into how the AI assistant response was generated.

By clicking on the thumbs up or thumbs down icons, you can quickly rate the AI assistant response. This feedback score will be logged and associated to
the relevant trace. By switching to the trace view, you can review the full trace as well as add additional feedback scores through the annotation
functionality.

<Frame>
  <img src="/img/tracing/chat_conversations_actions.png" />
</Frame>

## Scoring conversations

It is possible to assign conversation level feedback scores. For that, you need to understand how threads work in Opik. Threads are aggregated traces
that are created when tracking agents or simply traces interconnected by a `thread_id`. In order to score a conversation, we need to ensure that the
thread is inactive, meaning that no new traces are being created.

<Note>
  By default, threads are marked as inactive after 15 minutes of inactivity. You can change this value by setting the
  `OPIK_TRACE_THREAD_TIMEOUT_TO_MARK_AS_INACTIVE` environment variable (If you are using the Opik self-hosted version).
  On cloud, you can change this setting at workspace level.
</Note>

Threads are automatically marked as inactive after the timeout period and you can also manually mark a thread as inactive via UI using the `Status` button on top right corner of the thread view.

<Frame>
  <img src="/img/tracing/chat_conversations_mark_as_inactive.png" />
</Frame>

Once a thread is inactive, you can assign a feedback score to the thread. This score will be associated to the thread and will be displayed in the thread view.

<Frame>
  <img src="/img/tracing/chat_conversations_score.png" />
</Frame>

And in the conversation list, you can see the feedback score associated to the thread.

<Frame>
  <img src="/img/tracing/chat_conversations_score_list.png" />
</Frame>

<Note>
  Important: The human feedback scores are removed in case the thread is re-activated. This is to avoid any confusion
  and to ensure that the feedback scores are always based on the full context of the conversation.
</Note>

You can also tag a thread and add comments to it. This is useful to add additional context during the review process or investigate a specific conversation.

<Frame>
  <img src="/img/tracing/chat_conversation_tags_comments.png" />
</Frame>

## Advanced Thread Features

### Filtering and Searching Threads

You can filter threads using the `thread_id` field in various Opik features:

#### In Data Export

When exporting data, you can filter by `thread_id` using these operators:

- `=` (equals), `!=` (not equals)
- `contains`, `not_contains`
- `starts_with`, `ends_with`
- `>`, `<` (lexicographic comparison)

#### In Thread Evaluation

You can evaluate entire conversation threads using the thread evaluation features. This is particularly useful for:

- Conversation quality assessment
- Multi-turn coherence evaluation
- User satisfaction scoring across complete interactions

### Thread Lifecycle Management

Threads have a lifecycle that affects how you can interact with them:

1. **Active**: New traces can be added to the thread
2. **Inactive**: No new traces can be added, thread can be scored

<Note>
  Threads automatically become inactive after 15 minutes of no new trace activity. This timeout can be configured: -
  **Self-hosted**: Set `OPIK_TRACE_THREAD_TIMEOUT_TO_MARK_AS_INACTIVE` environment variable - **Cloud**: Configure at
  workspace level in settings
</Note>

### Programmatic Thread Management

You can also manage threads programmatically using the Opik SDK:

```python
import opik

# Initialize client
client = opik.Opik()

# Search for threads by various criteria
threads = client.search_traces(
    project_name="my-chatbot",
    filter_string='thread_id contains "user-session"'
)

# Get specific thread content
for trace in threads:
    if trace.thread_id:
        thread_content = client.get_trace_content(trace.id)
        print(f"Thread: {trace.thread_id}")
        print(f"Input: {thread_content.input}")
        print(f"Output: {thread_content.output}")

# Add feedback scores to thread traces
for trace in threads:
    trace.log_feedback_score(
        name="conversation_quality",
        value=0.8,
        reason="Good multi-turn conversation flow"
    )
```

### Thread Metadata and Context

Enhance your threads with rich metadata for better organization:

```python
import opik
from opik import opik_context

@opik.track
def enhanced_conversation_turn(user_message, user_id, conversation_type):
    thread_id = f"{user_id}-{conversation_type}-session"

    opik_context.update_current_trace(
        thread_id=thread_id,
        metadata={
            "user_id": user_id,
            "conversation_type": conversation_type,
            "channel": "web_chat",
            "language": "en",
            "session_start": "2024-01-15T10:30:00Z"
        },
        tags=["production", "customer-support", conversation_type]
    )

    # Process message and return response
    return f"AI response to: {user_message}"
```

This enhanced metadata helps with:

- **Filtering**: Find conversations by type, channel, or language
- **Analytics**: Analyze conversation patterns and user behavior
- **Debugging**: Quickly identify problematic conversation flows
- **Reporting**: Generate insights on conversation quality and outcomes
