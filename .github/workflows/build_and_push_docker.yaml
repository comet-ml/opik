name: "Build Docker Images Multi-Arch"

run-name: "Build ${{ inputs.image }}${{ inputs.build_comet_image && '-comet' || '' }} - ${{ inputs.version }}"

on:
  workflow_call:
    inputs:
      image:
        type: string
        required: true
        description: Docker Image
      version:
        type: string
        required: true
        description: Version
      build_from:
        type: string
        required: true
        description: Original version to build from 
        default: ""
      build_comet_image:
        type: boolean
        required: true
        description: If to build a Comet integration image
        default: false
      comet_build_args:
        type: string
        required: false
        default: ""
        description: Arguments for cloud docker build
      is_release:
        type: boolean
        required: true
        description: If this is a release build (will build multi-arch and push latest tag)
        default: false
    secrets:
      OPIK_FE_SENTRY_DSN:
        required: false
  workflow_dispatch:
    inputs:
      image:
        type: string
        required: true
        description: Docker Image
      version:
        type: string
        required: true
        description: Version
      build_from:
        type: string
        required: true
        description: Original version to build from 
        default: ""
      build_comet_image:
        type: boolean
        required: true
        description: If to build a Comet integration image
        default: false
      comet_build_args:
        type: string
        required: false
        default: ""
        description: Arguments for cloud docker build
      is_release:
        type: boolean
        required: true
        description: If this is a release build (will build multi-arch and push latest tag)
        default: false

env:
  DOCKER_REGISTRY: "ghcr.io/comet-ml/opik"

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - image_type: regular
            image_suffix: ""
            platform: amd64
          - image_type: regular
            image_suffix: ""
            platform: arm64
            skip_guardrails: true
          - image_type: comet
            image_suffix: "-comet"
            platform: amd64
          - image_type: comet
            image_suffix: "-comet"
            platform: arm64
            skip_guardrails: true
    runs-on: ${{ matrix.platform == 'amd64' && 'ubuntu-latest' || 'ubuntu-24.04-arm' }}
    name: ${{ matrix.platform }} ${{ inputs.image }}${{ matrix.image_suffix }}
    permissions:
      contents: read
      packages: write
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      platform: ${{ matrix.platform }}
      image_name: ${{ steps.set_vars.outputs.image_name }}
    timeout-minutes: 60
    steps:
      - name: Check if job should run
        id: check
        run: |
          SHOULD_RUN="false"
          if [[ "${{ matrix.image_type }}" == "regular" ]] || [[ "${{ inputs.build_comet_image }}" == "true" ]]; then
            if [[ "${{ matrix.platform }}" != "arm64" ]] || [[ "${{ matrix.skip_guardrails }}" != "true" ]] || [[ "${{ inputs.image }}" != "opik-guardrails-backend" ]]; then
              SHOULD_RUN="true"
            fi
          fi
          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT
      
      - name: Set image variables
        id: set_vars
        if: steps.check.outputs.should_run == 'true'
        run: |
          if [[ "${{ matrix.image_type }}" == "comet" ]]; then
            IMAGE_NAME="${{ inputs.image }}-comet"
          else
            IMAGE_NAME="${{ inputs.image }}"
          fi
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Checkout
        if: steps.check.outputs.should_run == 'true'
        uses: actions/checkout@v4.1.1
        with:
          ref: ${{ inputs.build_from }}

      - name: Save opik-sandbox-executor-python
        if: steps.check.outputs.should_run == 'true' && inputs.image == 'opik-python-backend'
        run: |
          docker pull ${{env.DOCKER_REGISTRY}}/opik-sandbox-executor-python:${{inputs.version}}
          docker save ${{env.DOCKER_REGISTRY}}/opik-sandbox-executor-python:${{inputs.version}} | gzip > apps/opik-python-backend/opik-sandbox-executor-python.tar.gz

      - name: Login to GHCR
        if: steps.check.outputs.should_run == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        if: steps.check.outputs.should_run == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata (tags, labels) for Docker
        if: steps.check.outputs.should_run == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ steps.set_vars.outputs.image_name }}
          tags: |
            type=raw,value=${{ inputs.version }}
            type=raw,value=latest,enable=${{ inputs.is_release == true }}
            type=raw,value=main,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and Push Docker Image
        if: steps.check.outputs.should_run == 'true'
        id: build
        uses: docker/build-push-action@v6
        with:
          context: apps/${{ inputs.image }}/
          platforms: linux/${{ matrix.platform }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ steps.set_vars.outputs.image_name }}:main
          provenance: false
          load: true
          outputs: type=image,name=${{ env.DOCKER_REGISTRY }}/${{ steps.set_vars.outputs.image_name }},push-by-digest=true,name-canonical=true,push=true
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            OPIK_VERSION=${{ inputs.version }}
            ${{ matrix.image_type == 'comet' && inputs.comet_build_args || '' }}
            ${{ matrix.image_type == 'comet' && 'SENTRY_ENABLED=true' || '' }}
            ${{ matrix.image_type == 'comet' && format('SENTRY_DSN={0}', secrets.OPIK_FE_SENTRY_DSN) || '' }}
          secrets: |
            ${{ matrix.image_type == 'comet' && format('OPIK_FE_SENTRY_DSN={0}', secrets.OPIK_FE_SENTRY_DSN) || '' }}
            GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}

  merge:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include:
          - image_type: regular
            image_suffix: ""
          - image_type: comet
            image_suffix: "-comet"
    steps:
      - name: Check if job should run
        id: check
        run: |
          SHOULD_RUN="false"
          if [[ "${{ matrix.image_type }}" == "regular" ]] || [[ "${{ inputs.build_comet_image }}" == "true" ]]; then
            SHOULD_RUN="true"
          fi
          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT
      
      - name: Set image variables
        id: set_vars
        if: steps.check.outputs.should_run == 'true'
        run: |
          if [[ "${{ matrix.image_type }}" == "comet" ]]; then
            IMAGE_NAME="${{ inputs.image }}-comet"
          else
            IMAGE_NAME="${{ inputs.image }}"
          fi
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Collect digests from build jobs
        if: steps.check.outputs.should_run == 'true'
        id: collect_digests
        run: |
          # Collect digests from build job outputs
          # Filter to only include digests for the current image type (regular or comet)
          # Build jobs output: digest, platform, image_name
          # We need to match image_name to filter correct digests
          
          PLATFORMS="amd64"
          if [[ "${{ inputs.image }}" != "opik-guardrails-backend" ]]; then
            PLATFORMS="$PLATFORMS arm64"
          fi
          
          # Get all outputs from build jobs
          BUILD_DIGESTS="${{ needs.build.outputs.digest }}"
          BUILD_IMAGE_NAMES="${{ needs.build.outputs.image_name }}"
          BUILD_PLATFORMS="${{ needs.build.outputs.platform }}"
          
          # Current image name for this merge job (regular or comet)
          CURRENT_IMAGE_NAME="${{ steps.set_vars.outputs.image_name }}"
          
          echo "Current image name: $CURRENT_IMAGE_NAME"
          echo "Expected platforms: $PLATFORMS"
          echo "All build digests: $BUILD_DIGESTS"
          echo "All build image names: $BUILD_IMAGE_NAMES"
          echo "All build platforms: $BUILD_PLATFORMS"
          
          # Check if any build jobs ran for this image type
          if [[ -z "$BUILD_IMAGE_NAMES" ]] || [[ "$BUILD_IMAGE_NAMES" != *"$CURRENT_IMAGE_NAME"* ]]; then
            # If this is a comet image and build_comet_image is false, that's expected - skip gracefully
            if [[ "$CURRENT_IMAGE_NAME" == *"-comet" ]] && [[ "${{ inputs.build_comet_image }}" != "true" ]]; then
              echo "Comet image not built (build_comet_image=false), skipping merge for $CURRENT_IMAGE_NAME"
              echo "digests_platforms=$PLATFORMS" >> $GITHUB_OUTPUT
              echo "build_digests=" >> $GITHUB_OUTPUT
              echo "skip_merge=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "ERROR: No build jobs found for image: $CURRENT_IMAGE_NAME"
            echo "This may indicate build jobs were skipped or failed"
            echo "Available image names from build jobs: $BUILD_IMAGE_NAMES"
            exit 1
          fi
          
          # Filter digests that match current image_name
          # Since matrix outputs are aggregated, we need to match digests to image names
          FILTERED_DIGESTS=""
          BASE_IMAGE="${{ env.DOCKER_REGISTRY }}/$CURRENT_IMAGE_NAME"
          
          # Convert space-separated strings to arrays
          read -ra DIGEST_ARRAY <<< "$BUILD_DIGESTS"
          read -ra IMAGE_NAME_ARRAY <<< "$BUILD_IMAGE_NAMES"
          read -ra PLATFORM_ARRAY <<< "$BUILD_PLATFORMS"
          
          echo "Filtering digests for image: $CURRENT_IMAGE_NAME"
          
          for i in "${!DIGEST_ARRAY[@]}"; do
            DIGEST="${DIGEST_ARRAY[$i]}"
            IMAGE_NAME="${IMAGE_NAME_ARRAY[$i]}"
            PLATFORM="${PLATFORM_ARRAY[$i]}"
            
            # Match by image_name first (faster than registry check)
            if [[ "$IMAGE_NAME" == "$CURRENT_IMAGE_NAME" ]]; then
              # Verify digest exists and belongs to correct image
              DIGEST_REF="$BASE_IMAGE@$DIGEST"
              if docker buildx imagetools inspect "$DIGEST_REF" >/dev/null 2>&1; then
                echo "  ✓ Matched digest for $IMAGE_NAME ($PLATFORM): $DIGEST"
                FILTERED_DIGESTS="$FILTERED_DIGESTS $DIGEST"
              else
                echo "  ⚠ Digest not found in registry: $DIGEST_REF (skipping)"
              fi
            fi
          done
          
          FILTERED_DIGESTS=$(echo "$FILTERED_DIGESTS" | xargs)  # Trim whitespace
          
          if [ -z "$FILTERED_DIGESTS" ]; then
            echo "ERROR: No digests found for image: $CURRENT_IMAGE_NAME"
            echo "Available image names: $BUILD_IMAGE_NAMES"
            exit 1
          fi
          
          echo "Filtered digests for $CURRENT_IMAGE_NAME: $FILTERED_DIGESTS"
          echo "digests_platforms=$PLATFORMS" >> $GITHUB_OUTPUT
          echo "build_digests=$FILTERED_DIGESTS" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        if: steps.check.outputs.should_run == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        if: steps.check.outputs.should_run == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        if: steps.check.outputs.should_run == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ steps.set_vars.outputs.image_name }}
          tags: |
            type=raw,value=${{ inputs.version }}
            type=raw,value=latest,enable=${{ inputs.is_release == true }}
            type=raw,value=main,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Create manifest list and push tags
        if: steps.check.outputs.should_run == 'true' && steps.collect_digests.outputs.skip_merge != 'true' && steps.collect_digests.outputs.build_digests != ''
        run: |
          # Use digests collected from build job outputs
          PLATFORMS="${{ steps.collect_digests.outputs.digests_platforms }}"
          BUILD_DIGESTS="${{ steps.collect_digests.outputs.build_digests }}"
          BASE_IMAGE="${{ env.DOCKER_REGISTRY }}/${{ steps.set_vars.outputs.image_name }}"
          
          if [ -z "$BUILD_DIGESTS" ]; then
            echo "No digests to process, skipping manifest creation"
            exit 0
          fi
          
          echo "Collecting digests for platforms: $PLATFORMS"
          echo "Build job digests: $BUILD_DIGESTS"
          
          DIGESTS=""
          
          # For each platform, find matching digest by checking manifest architecture
          for platform in $PLATFORMS; do
            echo "Looking for digest for platform: $platform"
            
            # Try each digest from build outputs
            for digest in $BUILD_DIGESTS; do
              if [ -n "$digest" ]; then
                DIGEST_REF="$BASE_IMAGE@$digest"
                
                # Verify digest exists and check its platform
                if docker buildx imagetools inspect "$DIGEST_REF" >/dev/null 2>&1; then
                  # Check manifest architecture
                  MANIFEST_INFO=$(docker buildx imagetools inspect "$DIGEST_REF" --raw 2>/dev/null || echo "{}")
                  MANIFEST_ARCH=$(echo "$MANIFEST_INFO" | jq -r '.architecture // empty' 2>/dev/null || echo "")
                  
                  if [[ "$MANIFEST_ARCH" == "$platform" ]] || [[ -z "$MANIFEST_ARCH" ]]; then
                    echo "  ✓ Found digest for $platform: $DIGEST_REF"
                    DIGESTS="$DIGESTS $DIGEST_REF"
                    break
                  fi
                fi
              fi
            done
          done
          
          if [ -z "$DIGESTS" ]; then
            echo "ERROR: Could not find any valid digests in registry"
            echo "Build job outputs: digest=$BUILD_DIGESTS"
            exit 1
          fi
          
          echo ""
          echo "Collected digests: $DIGESTS"
          echo "Tags from metadata:"
          echo "${{ steps.meta.outputs.tags }}"
          echo "Labels from metadata:"
          echo "${{ steps.meta.outputs.labels }}"
          
          # Create and push manifest using metadata tags
          # Metadata outputs tags as newline-separated string, convert to -t flags
          TAG_ARGS=""
          while IFS= read -r tag; do
            if [ -n "$tag" ]; then
              TAG_ARGS="$TAG_ARGS -t $tag"
            fi
          done <<< "${{ steps.meta.outputs.tags }}"
          
          if [ -z "$TAG_ARGS" ]; then
            echo "ERROR: No tags generated from metadata!"
            exit 1
          fi
          
          echo "Creating manifest with tags: $TAG_ARGS"
          echo "Using digests: $DIGESTS"
          docker buildx imagetools create $TAG_ARGS $DIGESTS

      - name: Write Build Summary
        if: steps.check.outputs.should_run == 'true'
        run: |
          echo "### Docker images pushed: ${{ steps.set_vars.outputs.image_name }}" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ inputs.image }}" == "opik-guardrails-backend" ]]; then
            echo "Built for platforms: linux/amd64" >> $GITHUB_STEP_SUMMARY
          else
            echo "Built for platforms: linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- [View on GitHub Container Registry](https://github.com/${{ github.repository }}/pkgs/container/opik%2F${{ steps.set_vars.outputs.image_name }})" >> $GITHUB_STEP_SUMMARY

